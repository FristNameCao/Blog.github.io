<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逻辑与&amp;&amp;和逻辑或||的本质和区别？</title>
      <link href="/2023/02/14/%E9%80%BB%E8%BE%91%E4%B8%8E&amp;&amp;%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2023/02/14/%E9%80%BB%E8%BE%91%E4%B8%8E&amp;&amp;%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑与-也叫作短路与"><a href="#逻辑与-也叫作短路与" class="headerlink" title="逻辑与:也叫作短路与"></a>逻辑与:也叫作短路与</h1><ul><li>从左往右,依次计算 </li><li>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较 </li><li>true ,继续下⼀个⽐较 </li><li>false ,直接返回该运算元的初始值 </li><li>如果找到最后也没有找到,就返回最后⼀个运算元</li></ul><h1 id="逻辑或-也叫做短路或"><a href="#逻辑或-也叫做短路或" class="headerlink" title="逻辑或:也叫做短路或"></a>逻辑或:也叫做短路或</h1><p>从左往右,依次计算 </p><p>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较 </p><p>true ,直接返回该运算元的初始值 </p><p>false ,继续下⼀个⽐较 </p><p>如果找到最后也没有找到,就返回最后⼀个运算元</p>]]></content>
      
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==和===</title>
      <link href="/2023/02/14/==%E5%92%8C===/"/>
      <url>/2023/02/14/==%E5%92%8C===/</url>
      
        <content type="html"><![CDATA[<h1 id="x3D-x3D-普通相等"><a href="#x3D-x3D-普通相等" class="headerlink" title="&#x3D;&#x3D; (普通相等)"></a>&#x3D;&#x3D; (普通相等)</h1><p>在类型不相同的情况下, 会将运算元先转成Number的值, 再进⾏⽐较(隐式转换) </p><p>null⽐较特殊: null在进⾏⽐较的时候, 应该是会被当成⼀个对象和原⽣类型进⾏⽐较的 </p><h1 id="x3D-x3D-x3D-严格不等"><a href="#x3D-x3D-x3D-严格不等" class="headerlink" title="&#x3D;&#x3D;&#x3D; (严格不等)"></a>&#x3D;&#x3D;&#x3D; (严格不等)</h1><p>在类型不同的情况下,直接返回false</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i++和++i</title>
      <link href="/2023/02/14/i++%E5%92%8C++i/"/>
      <url>/2023/02/14/i++%E5%92%8C++i/</url>
      
        <content type="html"><![CDATA[<h1 id="count-和-count的区别"><a href="#count-和-count的区别" class="headerlink" title="count++和++count的区别?"></a>count++和++count的区别?</h1><ul><li>如果它们在计算之后的值不会被使⽤ 是没有区别的 </li><li>如果需要⽴刻使⽤⾃增之后的值 就⽤前置型 反之后置型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var num = 1 + ++count // 不推荐这么写</span><br><span class="line">//需要⽴刻使⽤的话</span><br><span class="line">count++</span><br><span class="line">var num = 1 +count //++count</span><br><span class="line">//不需要的话</span><br><span class="line">var num = 1 + count //count++</span><br><span class="line">count++</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 自加 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型</title>
      <link href="/2023/02/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/02/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-中的常⻅数据类型"><a href="#JavaScript-中的常⻅数据类型" class="headerlink" title="JavaScript 中的常⻅数据类型"></a>JavaScript 中的常⻅数据类型</h1><h3 id="Number-gt-代表数据类型是数值"><a href="#Number-gt-代表数据类型是数值" class="headerlink" title="Number -&gt; 代表数据类型是数值"></a>Number -&gt; 代表数据类型是数值</h3><ul><li><p>整数 </p></li><li><p>浮点</p></li><li><p>数组</p></li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>String -&gt; 代表字符串类型 -&gt; 通常是⼀段⽂本</li></ul><h3 id="boolean-gt-布尔类型"><a href="#boolean-gt-布尔类型" class="headerlink" title="boolean -&gt; 布尔类型"></a>boolean -&gt; 布尔类型</h3><ul><li>true </li><li>false</li></ul><p>NULL -&gt; 空值 </p><p>undefifined -&gt; 变量未定义 </p><p>Object -&gt; 对象类型 </p><p>BigInt -&gt; ⼤整数类型 </p><p>Symbol -&gt; 符号类型</p>]]></content>
      
      
      <categories>
          
          <category> js数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常⻅的节点（Node）属性</title>
      <link href="/2023/02/14/%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/"/>
      <url>/2023/02/14/%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>nodeType </p><ul><li><p>获取节点的类型 </p></li><li><p>⽐如 注释节点8 ⽂本节点3 元素节点1</p></li></ul></li><li><p>tagName </p><ul><li>获取元素的标签名词 仅适⽤于Element节点</li></ul></li><li><p>nodeName </p><ul><li>获取元素的标签名词 适⽤于任何Node节点</li></ul></li><li><p>innerHTML,textContent </p><ul><li>前者将元素中的HTML获取为字符串属性 后者仅仅获取⽂本内容</li></ul></li><li><p>outerHTML </p><ul><li>包含了完整的HTML </li><li>相当于innerHTML加上元素本身</li></ul></li><li><p>nodeValue&#x2F;data </p><ul><li>获取⾮元素节点的⽂本内容</li></ul></li><li><p>hidden </p><ul><li>⽤于设置元素隐藏(全局属性)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节点（Node) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调和匿名</title>
      <link href="/2023/02/14/%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8C%BF%E5%90%8D/"/>
      <url>/2023/02/14/%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8C%BF%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h1><h4 id="⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数"><a href="#⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数" class="headerlink" title="⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数"></a>⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数</h4><h1 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h1><h4 id="如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，"><a href="#如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，" class="headerlink" title="如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，"></a>如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，</h4><h4 id="那么这个函数称之为匿名函数"><a href="#那么这个函数称之为匿名函数" class="headerlink" title="那么这个函数称之为匿名函数"></a>那么这个函数称之为匿名函数</h4>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回调和匿名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM和document对象的理解</title>
      <link href="/2023/02/14/DOM%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/02/14/DOM%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对DOM和document对象的理解"><a href="#对DOM和document对象的理解" class="headerlink" title="对DOM和document对象的理解"></a>对DOM和document对象的理解</h1><h2 id="DOM-⽂档对象模型-Document-Object-Model-将⻚⾯所有的内容表示为可以修改的对象"><a href="#DOM-⽂档对象模型-Document-Object-Model-将⻚⾯所有的内容表示为可以修改的对象" class="headerlink" title="DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象"></a>DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象</h2><ul><li><p>浏览器将我们编写在HTML中的每⼀个元素(Element)都抽象成了⼀个个对象 </p></li><li><p>所有这些对象都可以通过JavaScript来对其进⾏访问，那么我们就可以通过JavaScript来操作 </p></li><li><p>⻚⾯; </p></li><li><p>所以，我们将这个抽象过程称之为 ⽂档对象模型(Document Object Model)</p></li><li><p>Document节点表示的整个载⼊的⽹⻚，它的实例是全局的document对象:对DOM的所有操作都是从 document 对象开始的 </p></li><li><p>它是DOM的⼊⼝点，可以从document开始去访问任何节点元素;</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DOM和document对象的理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object_CSD</title>
      <link href="/2023/02/12/Object-CSD/"/>
      <url>/2023/02/12/Object-CSD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据及结构与对象"><a href="#数据及结构与对象" class="headerlink" title="数据及结构与对象"></a>数据及结构与对象</h1><p>Math[PI] </p><p>此种语法，中括号里面是一个表达式 表达式计算结果应该是一个字符串 该字符串被当做要读取的属性的名 整个表达式返回该属性的属性值  </p><p>Math[“PI”]</p><p>Math[‘P’+’I’]</p><p>x&#x3D;”PI”</p><p>Math[x]</p><p>是可以的</p><p>&#x2F;&#x2F; 数组是值的“有序”集合</p><p> &#x2F;&#x2F; 对象是值的“具名”集合 </p><p>&#x2F;&#x2F; 在数组中，我们为值编号 </p><p>&#x2F;&#x2F; 在对象中，我们为值起名 </p><p>&#x2F;&#x2F; 有些语言里，对象又叫关联数组 </p><p>&#x2F;&#x2F;   把值与名字“关联”起来 </p><p>JS中一切皆对象（除空值以外）</p><p>因为一切都能读出属性</p><p>因为对于任何一个值来说，以下表达式都不报错</p><p>在其它很多语言里，能读出属性的只有对象</p><p>从能否可再拆分的角度讲，原始类型不算对象</p><p>但从能否读取属性的角度讲，原始类型也算对象，因为它们能读出属性</p><p>x &#x3D; 2</p><p>x.toFixed()</p><p>y &#x3D; ‘owiejfo’</p><p>y.length</p><p>y.toUpperCase()</p><p>z &#x3D; true</p><p>z.toString()</p><blockquote><p>c&#x3D;&#x3D; a&#x2F;&#x2F;相等运算判断对象时，返回的是两边是否是同一个对象<br>&#x2F;&#x2F;而判断原始类型时工返回的是两边的值是否相同</p></blockquote><p>为了找出对象具有的属性，可以使用 Object.keys 函数。 </p><p>你给它一个对象，它返回一个字符 </p><p>串数组 - 对象的属性名称</p><p>console.log(Object.keys({x: 0, y: 0, z: 2})); </p><p>&#x2F;&#x2F; → [“x”, “y”, “z”]</p><p><strong>Object.assign（）</strong> 方法将所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>（ 返回 true）和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">自有</a>（ 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。 </p><p>实列一</p><p>let objectA &#x3D; {a: 1, b: 2}; </p><p>Object.assign(objectA, {b: 3, c: 4}); </p><p>console.log(objectA); </p><p>&#x2F;&#x2F; → {a: 1, b: 3, c: 4} </p><p>实列二</p><p>const target &#x3D; { a: 1, b: 2 };<br>const source &#x3D; { b: 4, c: 5 };</p><p>const returnedTarget &#x3D; Object.assign(target, source);</p><p>console.log(target);<br>&#x2F;&#x2F; expected output: Object { a: 1, b: 4, c: 5 }</p><p>console.log(returnedTarget);<br>&#x2F;&#x2F; expected output: Object { a: 1, b: 4, c: 5 }</p><p>copyWithin（0，3，6）将3-6复制到前面</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/2023/02/12/Array/"/>
      <url>/2023/02/12/Array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h1><p>数组是值的有序集合</p><p>元素在数组中从0开始编号</p><p>创建数组 var a &#x3D; [1,2,3]</p><p>创建数组 var a &#x3D; Array(6) 创建长度为6的数组</p><p>创建数组 var a &#x3D; Array(6).fill(0) 创建长度为6的数组</p><p>创建数组 var a &#x3D; Array(6,5,4,3) 创建由6，5，4，3组成的数组</p><p>获取数组的长度 a.length</p><p>获取数组中的元素 a[i] ，i是元素在数组中的编号&#x2F;索引&#x2F;下标，下标只有整数</p><p>a[表达式]，，表达式计算出一个整数，</p><p>这个整体也是一个表达式，求值结果为数组中的某一项</p><p>a[i] &#x3D; 8 向数组的第i项赋值，之前的值就被扔了</p><p>任意值都可以放入数组中，如null，undefined，2，3，5，”owiefj”, true，函数，数组（因为数组本身也是值）</p><p>向数组末尾添加一个元素： a.push(1) 返回数组新的长度</p><p>向数组末尾添加多个元素： a.push(1,2,3,4) 返回数组新的长度</p><p>从数组的末尾删除并返回元素 var result &#x3D; a.pop()</p><p>向数组的开头添加一个元素 a.unshift(1) 返回数组新的长度</p><p>向数组的开头添加多个元素 a.unshift(1,2,3,4) 返回数组新的长度</p><p>从数组的开头删除并返回元素 var result &#x3D; a.shift()</p><p>将数组的内容填充为某个值 a.fill(5) 将数组所有的值都填成5</p><p>读取数组不存在的下标会得到undefined</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2023/02/12/Map/"/>
      <url>/2023/02/12/Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Map的封装"><a href="#Map的封装" class="headerlink" title="Map的封装"></a>Map的封装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">class Map2 &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">    this._keys = [] // 用来存储每组映射的key</span><br><span class="line"></span><br><span class="line">    this._vals = [] // 用来存储每组映射的val</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return this._vals[keyIdx]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123; // 判断映射中是否存在某个key的映射</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123; // 设置key的映射目标为val</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this._vals[keyIdx] = val</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      this._keys.push(key)</span><br><span class="line"></span><br><span class="line">      this._vals.push(val)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete(key) &#123; // 删除key的映射对</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this._keys.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      this._vals.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123; // 清空所有的映射</span><br><span class="line"></span><br><span class="line">    this._keys = []</span><br><span class="line"></span><br><span class="line">    this._vals = []</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // size() &#123; // 返回当前Map中映射对的数量</span><br><span class="line"></span><br><span class="line">  //   return this._keys.length</span><br><span class="line"></span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Map3 &#123;</span><br><span class="line"></span><br><span class="line">  #keys = [] // private class field</span><br><span class="line"></span><br><span class="line">  #vals = [] // private class field</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return this.#vals[keyIdx]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123; // 判断映射中是否存在某个key的映射</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123; // 设置key的映射目标为val</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this.#vals[keyIdx] = val</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      this.#keys.push(key)</span><br><span class="line"></span><br><span class="line">      this.#vals.push(val)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete(key) &#123; // 删除key的映射对</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this.#keys.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      this.#vals.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123; // 清空所有的映射</span><br><span class="line"></span><br><span class="line">    this.#keys = []</span><br><span class="line"></span><br><span class="line">    this.#vals = []</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123; // 返回当前Map中映射对的数量</span><br><span class="line"></span><br><span class="line">    return this.#keys.length</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class Stack &#123;</span><br><span class="line"></span><br><span class="line">  #size = 0</span><br><span class="line"></span><br><span class="line">  #top = null // 用于存储栈内元素的链表的头结点，由于头结点是栈顶，所以起名top</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 将元素val放入栈顶</span><br><span class="line">push(val) &#123;</span><br><span class="line">  var node = &#123;</span><br><span class="line">    val: val,</span><br><span class="line">    next: this.#top,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.#top = node</span><br><span class="line">  this.#size++</span><br><span class="line"></span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 返回栈顶元素并将其出栈</span><br><span class="line">pop() &#123;</span><br><span class="line">  if (this.#top) &#123;</span><br><span class="line">    var result = this.#top.val</span><br><span class="line">    this.#top = this.#top.next</span><br><span class="line">    this.#size--</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查看栈顶元素的值，但不让它出栈</span><br><span class="line">peek() &#123;</span><br><span class="line">  if (this.#top) &#123;</span><br><span class="line">    return this.#top.val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line">  return this.#size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 使用链表实现队列的抽象数据结构<br>  class Queue {<br>    constructor() {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进队</span><br><span class="line">enqueue(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 出队，将队头元素返回并从队列里删除</span><br><span class="line">dequeue() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 查看队头元素的值</span><br><span class="line">peek() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 表示一个集合：不重复的无序元素组成东西。<br>  class Group {<br>    constructor() {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">// 为集合中添加一个元素</span><br><span class="line">add(val) &#123;</span><br><span class="line"></span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 返回集合中是否有val这个元素</span><br><span class="line">has(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 从集合中删除val元素，返回是否删除成功</span><br><span class="line">delete(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 二维向量<br>  class Vector {<br>    constructor(x, y) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">// 用当前向量加上一个向量v，返回新的结果向量</span><br><span class="line">plus(v) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 用当前向量减去一个向量v，返回新的结果向量</span><br><span class="line">minus(v) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 实现复数及其四则运算<br>  class Complex {<br>    constructor(real, imag) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">plus(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">minus(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mul(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">divide(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以 (3+2j) 的形式返回复数的字符串形式</span><br><span class="line">toString() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  var c1 &#x3D; new Complex(2, 3)<br>  var c2 &#x3D; new Complex(5, -1)<br>  var c3 &#x3D; c1.mul(c2)</p><p></script></p>]]></content>
      
      
      <categories>
          
          <category> new Map() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdom</title>
      <link href="/2023/02/12/jsdom/"/>
      <url>/2023/02/12/jsdom/</url>
      
        <content type="html"><![CDATA[<p>元素的查找：<br>  getElements?.*()</p><p>元素的周围指针：<br>  el.firstChild&#x2F;lastChild&#x2F;nextSibiling&#x2F;previousSibiling<br>  el.parentNode&#x2F;parentElement<br>  el.firstElementChild&#x2F;lastElementChild<br>  el.nextElementSibiling&#x2F;previousElementSibiling<br>  el.childNodes&#x2F;children</p><p>元素的常用方法：<br>  对结点进行增删改<br>  el.appendChild(node)<br>  el.removeChild(node)<br>    node.remove()<br>  el.replaceChild(node, baseNode)<br>    baseNode.replaceWith(node)<br>  el.insertBefore(node, baseNode)</p><p>attr&amp;prop：<br>  node.xxxxx   dom property<br>  标准属性大都可以使用node.prop的形式访问,如<br>    id,title,alt,src,href,type,name,value<br>    class要用className,label的for属性要用htmlFor<br>  node.get&#x2F;set&#x2F;remove&#x2F;hasAttribute()   html attribute</p><p>新浏览器的一些方便的dom功能:<br>  el.classList.add&#x2F;remove&#x2F;replace&#x2F;toggle&#x2F;contains 访问及操作元素的class<br>  el.dataset.xxxYyyy 访问data-属性<br>  el.remove() 删除元素自身<br>    el.parentElement.removeChild(el)<br>  el.replaceWith(targetNode) 用targetNode替换el<br>  el.append(string, node, node, string, …)<br>  el.prepend(string, node, node, string, …)</p><p>  el.innerHTML 元素内部的结点的html表示,也可以赋值<br>  el.innerText 元素内部的文本内容,会受css影响<br>  el.textContent 元素内部的文本结点的值按顺序拼接得到的内容<br>  el.outerHTML 包含元素自身及内部的结点的html表示,也可以赋值,赋值会替换掉这个元素<br>    相当于在innerHTML的结果前后加上元素自身的开始和结束标签<br>  el.outerText 读取时等价于innerText,赋值时相当于用字符串替换该结点</p><p>function getInnerHTML(node) {</p><p>  var result &#x3D; ‘’<br>  for (var child of node.childNodes) {<br>      result +&#x3D; getOuterHTML(child)<br>  }<br>  return result</p><p>}</p><p>function getInnerHTML(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var result &#x3D; ‘’<br>    for (var child of node.childNodes) {<br>      if (child.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>        result +&#x3D; getInnerHTML(child)<br>      } else<br>        result +&#x3D; <code>&lt;$&#123;child.tagName&#125;&gt;</code> + getInnerHTML(child) + <code>&lt;/$&#123;child.tagName&#125;&gt;</code><br>    }<br>    return result<br>  }<br>}</p><p>function getTextContent(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var start &#x3D; &#96;&#96;<br>    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) {<br>      start +&#x3D; getTextContent(node.childNodes[i])<br>    }<br>    return start<br>  }<br>}</p><p>function getOuterHTML(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var tagName &#x3D; node.tagName.toLowerCase()<br>    var start &#x3D; <code>&lt;$&#123;tagName&#125;&gt;</code><br>    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) {<br>      start +&#x3D; getOuterHTML(node.childNodes[i])<br>    }<br>    return start + <code>&lt;/$&#123;tagName&#125;&gt;</code><br>  }<br>}</p><p>&#x2F;&#x2F; node.getElementsByTagName(tagName)<br>&#x2F;&#x2F; getElementsByTagName(node, tagName)</p><p>function getElementsByTagName(node, tagName) {<br>  var result &#x3D; []<br>  for (var child of node.children) {<br>    if (child.tagName &#x3D;&#x3D; tagName) {<br>      result.push(child)<br>    }<br>    result.push(…getElementsByTagName(child, tagName))<br>  }<br>  return result<br>}</p><p>function getElementsByTagName(node, tagName) {<br>  var result &#x3D; []<br>  &#x2F;&#x2F; 先序遍历node为根结点的dom树<br>  traverseDOM(node, it &#x3D;&gt; {<br>    &#x2F;&#x2F; 遇到的每个结点,如果是要找的标签名,则push到结果里<br>    if (it.tagName &#x3D;&#x3D; tagName) {<br>      result.push(it)<br>    }<br>  })<br>  &#x2F;&#x2F; 结果是一定不能包含根结点的<br>  &#x2F;&#x2F; 如果根结点在结果里,那么一定在第0项<br>  if (result[0] &#x3D;&#x3D; node) {<br>    result.shift()<br>  }<br>  return result<br>}</p><p>function traverseDOM(node, action &#x3D; console.log) {<br>  if (node.nodeType &#x3D;&#x3D; document.ELEMENT_NODE) {<br>    action(node)<br>    for (var child of node.children) {<br>      traverseDOM(child, action)<br>    }<br>  }<br>}</p><p>&#x2F;&#x2F; 带提前结束功能的遍历函数,让action返回false以提前结束<br>function traverseDOM(node, action &#x3D; console.log) {<br>  if (node.nodeType &#x3D;&#x3D; document.ELEMENT_NODE) {<br>    if (action(node) &#x3D;&#x3D;&#x3D; false) {<br>      return false<br>    }<br>    for (var child of node.children) {<br>      if (traverseDOM(child, action) &#x3D;&#x3D;&#x3D; false) {<br>        return false<br>      }<br>    }<br>  }<br>}</p><p>function getElementById(id, node &#x3D; document.documentElement) {<br>  if (node.id &#x3D;&#x3D;&#x3D; id) {<br>    return node<br>  } else {<br>    for (var child of node.children) {<br>      var result &#x3D; getElementById(id, child)<br>      if (result) {<br>        return result<br>      }<br>    }<br>    return null<br>  }<br>}</p><p>function getElementById(id) {<br>  var result &#x3D; null<br>  try {<br>    traverseDOM(document.documentElement, it &#x3D;&gt; {<br>      if (it.id &#x3D;&#x3D;&#x3D; id) {<br>        result &#x3D; it<br>        throw 2<br>      }<br>    })<br>  } catch (e) {<br>    if (e &#x3D;&#x3D;&#x3D; 2) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span><br><span class="line">  throw e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }<br>  return result<br>}<br>function getElementById(id) {<br>  var result &#x3D; null<br>  traverseDOM(document.documentElement, it &#x3D;&gt; {<br>    if (it.id &#x3D;&#x3D;&#x3D; id) {<br>      result &#x3D; it<br>      return false<br>    }<br>  })<br>  return result<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2023/02/11/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2023/02/11/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex:"></a>flex:</h1><p>大号的行内布局</p><h3 id="外层元素-flex-container-flex-容器"><a href="#外层元素-flex-container-flex-容器" class="headerlink" title="外层元素: flex container flex 容器"></a>外层元素: flex container flex 容器</h3><p>flex 窗口的子元素: flex item flex 元素</p><ul><li><p>flex-wrap:wrap 折行</p></li><li><p>flex-grow:0; &#x2F;_ 扩张权重_&#x2F;宽度的权重 默认为 0</p></li><li><p>flex-grow:0.x; &#x2F;<em>按照百分比获取剩余空间</em>&#x2F; 所有求和不超过 100%也就是 1 生效</p></li><li><p>flex-shrink:; &#x2F;<em>收缩系数</em>&#x2F; 默认 1</p></li><li><ul><li><p>不是 flex item 的 flex 父元素从外面看就像块元素一样<br>如宽度会打满包含块<br>但是子元素的 margin 不会超出去<br>但是相邻的元素垂直方向的 margin 还是会合并的</p></li><li><p>收缩或者扩张都不会让元素超出自己 min-w&#x2F;h 以及 max-w&#x2F;h 设定 的尺寸<br>收缩不能收到比自己的 min-width 还小<br>扩张不能扩张到比自己的 max-width 还大<br>收缩只发生在不折行的时候<br>因为如果折行就不可能存在空间不够的情况<br>flex 父元素”垂直”方向上的额外空间,只会均等的分配给每一行<br>当高度固定了如果还有额外空间用 height:auto;会自动分配填满</p></li></ul><h3 id="flex-父元素用来调用子元素摆放属性-justify-content"><a href="#flex-父元素用来调用子元素摆放属性-justify-content" class="headerlink" title="flex 父元素用来调用子元素摆放属性 justify-content"></a>flex 父元素用来调用子元素摆放属性 justify-content</h3><pre><code>* justify-content  设定一&quot;行&quot;的元素在行中的&quot;水平&quot;分布 start 项目与容器的左侧对齐。 end 项目与容器的右侧对齐 center 项目在容器的中心对齐 space-between 项目以相等的间距显示。 space-around 项目以等间距显示 space-evenly 平均分配物品</code></pre><p>项目在它们周围有相等的空间</p></li></ul><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>设定一”行”的元素在行中的”垂直”分布<br>start 项目与容器顶部对齐</p><p>end 项目与容器底部对齐</p><p>center 项目在容器的垂直中心对</p><p>baseline 项目显示在容器的基线处</p><p>stretch 物品被拉伸以适合容器</p><ul><li><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>​ 设定所有行(“行们”)在父元素垂直方向的分布<br>(设置父元素垂直方向上额外空间的分配)</p><pre><code> start flex-start: 线装在容器的顶部 end flex-end: 线装在容器的底部 center center: 线在容器的垂直中心包装 space-between：行以相等的间距显示 两边对齐   space-around  行以相等的间距显示在它们周围 space-evenly平均分配物品   项目在它们周围有相等的空间   stretch(额外空间均分给每一行)：线条被拉伸以适合容器   flex父元素&quot;垂直&quot;方向上的额外空间,只会均等的分配给每一行 * 不是flex item的flex父元素从外面看就像块元素一样如宽度会打满包含块   但是子元素的margin不会超出去   但是相邻的元素垂直方向的margin还是合并的</code></pre></li></ul><h3 id="flex-子元素用来调整自身摆放属性"><a href="#flex-子元素用来调整自身摆放属性" class="headerlink" title="flex 子元素用来调整自身摆放属性"></a>flex 子元素用来调整自身摆放属性</h3><pre><code>   align-self 类似align-items,但是只调整自己   order 调整自己的显示顺序(不是层叠顺序)   flex子元素不用定位就可以使用z-index属性  flex: 在一个属性上直接设置flex子元素的flex-grow flex-shrink flex-basis</code></pre><ul><li><p>flex: auto;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: auto;</code></pre></li><li><p>flex: 1;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: 0%;</code></pre></li><li><p>flex: 0;</p><pre><code>flex-grow: 0;flex-shrink: 1;flex-basis: 0%;</code></pre></li><li><p>flex: 100px;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: 100px;</code></pre></li><li><ul><li><p>flex-basis: 设定元素在主轴方向上的初始尺寸<br>当主轴水平时，它相当于 width</p><p>当主轴垂直时，它相当于 height</p><p>当它与 width&#x2F;height 一起用的时候，如果 flex-basis 的<br>值不为 auto，则它更优先</p></li></ul></li></ul><h3 id="flex-父元素的轴向-flex-direction"><a href="#flex-父元素的轴向-flex-direction" class="headerlink" title="flex 父元素的轴向:flex-direction"></a>flex 父元素的轴向:flex-direction</h3><pre><code>flex-direction: 设定主轴方向row 向右 项目的放置与文本方向相同row-reverse 向左 项目放置在与文本方向相反的位置column 向下 项目从上到下放置column-reverse 向上  项目从下到上放置</code></pre><h3 id="flex-wrap-设定交叉轴方向-交叉轴肯定跟主轴是垂直的"><a href="#flex-wrap-设定交叉轴方向-交叉轴肯定跟主轴是垂直的" class="headerlink" title="flex-wrap 设定交叉轴方向,交叉轴肯定跟主轴是垂直的"></a>flex-wrap 设定交叉轴方向,交叉轴肯定跟主轴是垂直的</h3><p>wrap 垂直与主轴,向右或向下</p><ul><li><p>项目环绕到其他行 ，类似于折行</p></li><li></li><li><p>wrap-reverse 垂直与主轴,向左或向上</p></li><li><p>项目反向环绕到附加行。</p></li><li><p>nowrap 每个项目都适合一行</p></li><li><p>不设定交叉轴方向,即不折行,所有元素在同一行或同一列</p></li><li></li><li><p>flex-flow 在一个属性上直接设置 flex-direction 和<br>flex-wrap 换行</p><p>flex-flow: wrap column; 换行 向下 项目从上到下放置</p><p>flex-grow 设定主轴方向上额外空间的分配<br>flex-shrink 设定主轴方向上空间收缩的系数</p><h2 id="flex-flow-弹性容器"><a href="#flex-flow-弹性容器" class="headerlink" title="flex-flow 弹性容器"></a>flex-flow 弹性容器</h2><p>*_ &#x2F;_ flex-flow: &lt;’flex-direction’&gt; *&#x2F;</p><p>flex-flow: row; 向右 项目的放置与文本方向相同</p><p>flex-flow: row-reverse; 向左 项目放置在与文本方向相反的位置</p><p>flex-flow: column; 向下 项目从上到下放置</p><p>flex-flow: column-reverse; 设置反转</p><p>&#x2F;_ flex-flow: &lt;’flex-wrap’&gt; _&#x2F;</p><p>flex-flow: nowrap;</p><p>flex-flow: wrap; 换行</p><p>flex-flow: wrap-reverse;</p><p>&#x2F;_ flex-flow: &lt;’flex-direction’&gt; and &lt;’flex-wrap’&gt; _&#x2F;</p><p>flex-flow: row nowrap;</p><p>flex-flow: column wrap;</p><p>flex-flow: column-reverse wrap-reverse;</p><p>&#x2F;_ Global values _&#x2F;</p><p>flex-flow: inherit;</p><p>flex-flow: initial;</p><p>flex-flow: revert;</p><p>flex-flow: revert-layer;</p><p>flex-flow: unset;</p><p>​</p></li></ul><h4 id="flex-父元素中的匿名文本"><a href="#flex-父元素中的匿名文本" class="headerlink" title="flex 父元素中的匿名文本"></a>flex 父元素中的匿名文本</h4><pre><code>flex父元素中的匿名文本相当于将该文本包进一个标签但不给该标签设置任何属性但它会受到flex父元素 justify-content, align-items, align-content属性的影响flex子元素的的margin：auto会均等的分配额外的空间，但晚于flex-grow对空间的占用</code></pre><h2 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h2><pre><code>设置在flex父元素用于指定子元素之间的间隙gap: &lt;row-gap&gt; &lt;column-gap&gt;;row-gap:column-gap: 行内flex元素,外面看是行内,里面看是flexdisplay: inline-flex 定位flex元素,外面看是定位,里面看是flexdisplay: flex;position: absolute;浮动flex元素,外面看是浮动,里面看是flexdisplay: flex;float: left;</code></pre><p><img src="D:\Blog\source_posts\flex.jpg" alt="flex"></p>]]></content>
      
      
      <categories>
          
          <category> flex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
