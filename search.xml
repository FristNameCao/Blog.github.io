<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本命年生日</title>
      <link href="/2023/02/15/%E6%9C%AC%E5%91%BD%E5%B9%B4%E7%94%9F%E6%97%A5/"/>
      <url>/2023/02/15/%E6%9C%AC%E5%91%BD%E5%B9%B4%E7%94%9F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="生日快乐"><a href="#生日快乐" class="headerlink" title="生日快乐"></a>生日快乐</h1><ul><li>今天是我人生中第二个本命年生日，这十二年自己经历了许许多多的挫折，受了数不清的委屈，走了不少弯路</li><li>但是这十二年我成长了很多，我懂得了如何提升自己学习能力，从一个不爱学习的小家伙成长为了一个爱学习的大家伙，从不自律，作息不规律的赖床虫改变成了一个早起不赖床的早起鸟</li><li>我不知道后面这十二年我会成长成什么样子的人，但是我会努力再努力，不会怕苦怕累，学会永久性独立思考，善于思考，懂于分析问题的成熟大叔</li><li>这个博客不知道我会维护多久，倘若下一个十二年还在，不知道那时候的我会不会觉得今天我说的话很幼稚呢，哈哈哈</li><li>好了，祝自己接下来找工作一切顺利吧，万事胜意</li><li><img src="https://s1.ax1x.com/2023/02/15/pSTbEtJ.jpg" alt="pSTbEtJ.jpg"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 生日 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO/AO/VO</title>
      <link href="/2023/02/14/GO-AO-VO/"/>
      <url>/2023/02/14/GO-AO-VO/</url>
      
        <content type="html"><![CDATA[<h1 id="对GO-x2F-AO-x2F-VO的理解"><a href="#对GO-x2F-AO-x2F-VO的理解" class="headerlink" title="对GO&#x2F;AO&#x2F;VO的理解"></a>对GO&#x2F;AO&#x2F;VO的理解</h1><h2 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h2><ul><li>Global Object JS代码在执⾏前会现在堆内存中创建⼀个全局对象(GO) </li><li>⽤于存放⼀些定义好的变量⽅法等包含Date Array String Number setTimeout等 </li><li>同时有⼀个window属性指向⾃⼰</li><li>同时在语法分析转成AST的过程中也会将⼀些变量 函数 存放在GO中 只是变量的初始值为 undefifined</li></ul><h2 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h2><ul><li>函数在执⾏前会先在堆内存中创建⼀个AO(Activation Object)对象 ⾥⾯存放这arguments 对应函数的形参 以及在函数中定义的变量 初始值为undefifined</li></ul><h2 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h2><ul><li>Variable Object 在执⾏函数时 会在执⾏上下⽂栈(ECS)中进⼊⼀个函数执⾏上下⽂(FEC)其中有三个核⼼ 核⼼之⼀是VO 指向的是该函数在内存中解析时创建的AO ⽽在全局执⾏上下⽂中指向的是GO</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO/AO/VO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2023/02/14/%E5%87%BD%E6%95%B0/"/>
      <url>/2023/02/14/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数-篇章"><a href="#函数-篇章" class="headerlink" title="函数 篇章"></a>函数 篇章</h1><h2 id="apply、call、bind函数的⽤法和区别？"><a href="#apply、call、bind函数的⽤法和区别？" class="headerlink" title="apply、call、bind函数的⽤法和区别？"></a>apply、call、bind函数的⽤法和区别？</h2><h4 id="⽤法："><a href="#⽤法：" class="headerlink" title="⽤法："></a>⽤法：</h4><ul><li><p>apply </p><p>第⼀个参数: 绑定this </p><p>第⼆个参数: 传⼊额外的实参, 以数组的形式</p></li><li><p>call </p><p>第⼀个参数: 绑定this </p><p>参数列表: 后续的参数以多参数的形式传递, 会作为实参 </p><p>bind(不希望obj对象身上有函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bar = foo.bind(obj)</span><br><span class="line">bar() // this -&gt; obj</span><br></pre></td></tr></table></figure></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>call、apply和bind都可以改变函数的this指向 </li><li>call、apply和bind第⼀个参数的是this要指向的对象 </li><li>call、apply和bind都可以后续为函数传参，apply是将参数并成⼀个数组，call和bind是将参数依次列出</li><li>call、apply都是直接调⽤，bind⽣成的this指向改变函数需要⼿动调⽤。</li></ul><h3 id="什么是纯函数？如何编写纯函数？"><a href="#什么是纯函数？如何编写纯函数？" class="headerlink" title="什么是纯函数？如何编写纯函数？"></a>什么是纯函数？如何编写纯函数？</h3><h4 id="纯函数：纯函数⼀般具有以下的特点："><a href="#纯函数：纯函数⼀般具有以下的特点：" class="headerlink" title="纯函数：纯函数⼀般具有以下的特点："></a>纯函数：纯函数⼀般具有以下的特点：</h4><ul><li><p>确定的输⼊⼀定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产⽣的结果） </p></li><li><p>纯函数的执⾏不会产⽣副作⽤。（函数内部的操作也不会对函数外部产⽣任何影响） </p></li><li><p>纯函数在react和redux中应⽤⽐较多。 </p><ul><li><p>编写纯函数：</p></li><li><pre><code>//⼀般的数学⽅法可以写成纯函数,例如相加function sum(...args) &#123;var result = args.reduce((perValue, item) =&gt; &#123;return preValue + item &#125;, 0)return result&#125;</code></pre></li></ul></li></ul><h3 id="什么是函数柯⾥化？柯⾥化有什么作⽤？"><a href="#什么是函数柯⾥化？柯⾥化有什么作⽤？" class="headerlink" title="什么是函数柯⾥化？柯⾥化有什么作⽤？"></a>什么是函数柯⾥化？柯⾥化有什么作⽤？</h3><h4 id="函数的柯⾥化："><a href="#函数的柯⾥化：" class="headerlink" title="函数的柯⾥化："></a>函数的柯⾥化：</h4><ul><li>将传⼊多个参数的函数转变成传⼊单个参数并且返回⼀个函数⽤于接收剩余的参数的函数 </li><li>每⼀层函数都接收⼀个参数并对参数进⾏处理。</li></ul><h4 id="柯⾥化的作⽤："><a href="#柯⾥化的作⽤：" class="headerlink" title="柯⾥化的作⽤："></a>柯⾥化的作⽤：</h4><ul><li>单⼀职责：每⼀个函数只⽤处理传⼊的单个参数，每个函数的职责单⼀⽽且确定 </li><li>参数复⽤：可以拿到每⼀层函数执⾏的返回值作为⼀个新的函数，复⽤已经传⼊过的参数。</li></ul><h3 id="组合函数以及组合函数的作⽤？"><a href="#组合函数以及组合函数的作⽤？" class="headerlink" title="组合函数以及组合函数的作⽤？"></a>组合函数以及组合函数的作⽤？</h3><h4 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h4><ul><li>组合函数是将多个函数组合到⼀起，进⾏依次调⽤的函数使⽤模式。</li></ul><h4 id="组合函数的作⽤："><a href="#组合函数的作⽤：" class="headerlink" title="组合函数的作⽤："></a>组合函数的作⽤：</h4><ul><li>减少重复代码的编写，提⾼代码的复⽤性，便于开发。</li><li>可以对任意个函数进⾏组合，返回新的具有多个被组合函数功能的新函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/02/14/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/14/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="常⽤的数组操作⽅法有哪些？"><a href="#常⽤的数组操作⽅法有哪些？" class="headerlink" title="常⽤的数组操作⽅法有哪些？"></a>常⽤的数组操作⽅法有哪些？</h2><h3 id="Array-shift"><a href="#Array-shift" class="headerlink" title="Array.shift()"></a>Array.shift()</h3><ul><li>删除并返回第⼀个元素作⽤：从数组中删除第⼀个元素（即下标为0的元素），并返回该元素。 注意：1）删除元素之后，数组的⻓度-1。</li></ul><h3 id="Array-pop"><a href="#Array-pop" class="headerlink" title="Array.pop()"></a>Array.pop()</h3><ul><li>删除并返回最后⼀个元素 作⽤：从数组中删除最后⼀个元素（即下标为length-1的元素），并返回该元素。 注意：1）删除元素之后，数组的⻓度-1。</li></ul><h3 id="Array-push-param1-param2-…paramN"><a href="#Array-push-param1-param2-…paramN" class="headerlink" title="Array.push(param1[,param2,…paramN])"></a>Array.push(param1[,param2,…paramN])</h3><ul><li>尾部添加元素 作⽤：在数组的尾部添加⼀个元素，并返回新数组的⻓度。 注意：1）它是直接修改该数组，⽽不是重新创建⼀个数组。</li></ul><h3 id="Array-unshift-newElement1-newElement2-…newElementN"><a href="#Array-unshift-newElement1-newElement2-…newElementN" class="headerlink" title="Array.unshift(newElement1[,newElement2,…newElementN])"></a>Array.unshift(newElement1[,newElement2,…newElementN])</h3><ul><li>头部添加元素 作⽤：在数组的头部添加⼀个或多个元素，并返回新数组的⻓度。 注意：1）它是直接修改该数组，⽽不是重新创建⼀个数组</li></ul><h3 id="Array-join-separator"><a href="#Array-join-separator" class="headerlink" title="Array.join([separator])"></a>Array.join([separator])</h3><ul><li>转换成字符串 作⽤：把数组的所有元素放⼊到⼀个字符串中。 注意：1）参数separator表示字符串中元素的分隔符，可以为空，默认为半⻆逗号。</li></ul><h3 id="Array-reverse"><a href="#Array-reverse" class="headerlink" title="Array.reverse()"></a>Array.reverse()</h3><ul><li><p>反转数组 作⽤：把数组的所有元素顺序反转。 注意：1）该⽅法会直接修改数组，⽽不会创建新的 </p><p>数组</p></li></ul><h2 id="数组如何进⾏降维（扁平化）"><a href="#数组如何进⾏降维（扁平化）" class="headerlink" title="数组如何进⾏降维（扁平化）"></a>数组如何进⾏降维（扁平化）</h2><ul><li><p>利⽤Array.some⽅法判断数组中是否还存在数组，es6展开运算符连接数组 </p></li><li><pre><code>let arr = [1,2,[3,4]]while (arr.some(item =&gt; Array.isArray(item))) &#123;arr = [].concat(...arr);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 使⽤数组的concat⽅法 </span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  let arr = [1,2,[3,4]]</span><br><span class="line">  let result = []</span><br><span class="line">  result = Array.prototype.concat.apply([], arr)</span><br></pre></td></tr></table></figure></code></pre></li><li><p>es6中的flat函数也可以实现数组的扁平化 </p></li><li><pre><code>let arr = [1,2,[&#39;a&#39;,&#39;b&#39;,[&#39;中&#39;,&#39;⽂&#39;,[1,2,3,[11,21,31]]]],3];let result = arr.flat( Infinity )<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 数组去重，能⽤⼏种⽅法实现？ </span><br><span class="line"></span><br><span class="line">+ 利⽤ES6 Set去重（ES6中最常⽤） </span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  function unique (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 利⽤for嵌套for，然后splice去重（ES5中最常⽤） </span><br><span class="line"></span><br><span class="line">+ ````</span><br><span class="line">  function unique(arr)&#123; </span><br><span class="line">  for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">  for(var j=i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">  if(arr[i]==arr[j])&#123; //第⼀个等同于第⼆个，splice⽅法删除第⼆个</span><br><span class="line">  arr.splice(j,1);</span><br><span class="line">  j--;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN和&#123;&#125;没</span><br><span class="line">  有去重，两个null直接消失了</span><br></pre></td></tr></table></figure></code></pre></li><li><p>利⽤indexOf去重 </p></li><li><pre><code>function unique(arr) &#123;if (!Array.isArray(arr)) &#123;console.log(&#39;type error!&#39;)return &#125;var array = [];for (var i = 0; i &lt; arr.length; i++) &#123;if (array .indexOf(arr[i]) === -1) &#123;array .push(arr[i]) &#125; &#125;return array;&#125;var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined,null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;,&#123;…&#125;] //NaN、&#123;&#125;没有去重<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 利⽤sort去重 </span><br><span class="line"></span><br><span class="line">+ ````</span><br><span class="line">  function unique(arr) &#123;</span><br><span class="line">  if (!Array.isArray(arr)) &#123;</span><br><span class="line">  console.log(&#x27;type error!&#x27;)</span><br><span class="line">  return;</span><br><span class="line">   &#125;</span><br><span class="line">  arr = arr.sort()</span><br><span class="line">  var arrry= [arr[0]];</span><br><span class="line">  for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (arr[i] !== arr[i-1]) &#123;</span><br><span class="line">  arrry.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  return arrry;</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  // [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;,</span><br><span class="line">  undefined] // NaN、&#123;&#125;没有去重</span><br></pre></td></tr></table></figure></code></pre></li><li><p>利⽤includes </p></li><li><pre><code>function unique(arr) &#123;if (!Array.isArray(arr)) &#123;console.log(&#39;type error!&#39;)return &#125;var array =[];for(var i = 0; i &lt; arr.length; i++) &#123;if( !array.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值array.push(arr[i]); &#125; &#125;return array&#125;var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined,null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]// &#123;&#125; 没有去重<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 利⽤fifilter</span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  function unique(arr) &#123;</span><br><span class="line">  return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">  //当前元素，在原始数组中的第⼀个索引==当前索引值，否则返回当前元素</span><br><span class="line">  return arr.indexOf(item, 0) === index;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  //[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span><br></pre></td></tr></table></figure></code></pre></li><li><p>利⽤递归去重 </p></li><li><pre><code>function unique(arr)&#123;return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);&#125;var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined,null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</code></pre></li></ul><h2 id="数组中的forEach和map的区别？"><a href="#数组中的forEach和map的区别？" class="headerlink" title="数组中的forEach和map的区别？"></a>数组中的forEach和map的区别？</h2><p>forEach() 和 map() 两个⽅法都是ECMA5中Array引进的新⽅法，都是⽤来遍历数组中的每⼀项。 </p><h4 id="它们之间的区别："><a href="#它们之间的区别：" class="headerlink" title="它们之间的区别："></a>它们之间的区别：</h4><ul><li>map速度⽐forEach快 </li><li>map会返回⼀个新数组，不对原数组产⽣影响,foreach不会产⽣新数组，forEach返回undefifined </li><li>map因为返回数组所以可以链式操作，forEach不能 </li><li>map⾥可以⽤return（return的是什么，相当于把数组中的这⼀项变为什么（并不影响原来的数 组，只是相当于把原数组克隆⼀份，把克隆的这⼀份的数组中的对应项改变了） 。 </li><li>forEach⾥⽤return不起作⽤，forEach不能⽤break，会直接报错。</li></ul><h2 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别?"></a>for in和for of的区别?</h2><p>在JavaScript中遍历数组通常是使⽤for…i循环，在ES5具有遍历数组功能的还有forEach、map、fifilter、 </p><p>some、every、reduce、reduceRight等。for…in和for…of是两种增强型循环，for…in是ES5标准，在 </p><p>ES6中新增了for…of的循环⽅式。</p><ul><li>for…in ：遍历以任意顺序迭代⼀个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性 </li><li>for…of：遍历在可迭代对象，包括 Array ， Map ， Set ， String ， TypedArray ，arguments 对象等等</li><li>它们的区别 :<ul><li>for…in可以遍历对象和数组，for…of不能遍历对象 </li><li>for…in 循环不仅遍历对象的键名，还会遍历⼿动添加的其它键，甚⾄包括原型链上的键 </li><li>for…in遍历的索引为字符串类型</li><li>for..of适⽤遍历数&#x2F;数组对象&#x2F;字符串&#x2F;map&#x2F;set等拥有迭代器对象的集合，但是不能遍历对象 </li><li>for…of与forEach()不同的是，它可以正确响应break、continue和return语句具有迭代器对象才可以使⽤for…of</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/02/14/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/02/14/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="你是如何理解闭包的-闭包到底是什么"><a href="#你是如何理解闭包的-闭包到底是什么" class="headerlink" title="你是如何理解闭包的,闭包到底是什么?"></a>你是如何理解闭包的,闭包到底是什么?</h1><ul><li><p>什么是闭包？ </p><p>⼀个普通的函数function，如果它可以访问外层作⽤域的⾃由变量，那么这个函数和周围环境就是⼀个闭包。 </p><p>从狭义的⻆度来说：JavaScript中⼀个函数，如果访问了外层作⽤域的变量，那么它是⼀个闭包</p></li><li><p>应⽤场景 </p><p>防抖 、节流 、⽴即执⾏函数 、组合函数等等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域</title>
      <link href="/2023/02/14/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/02/14/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="作⽤域和作⽤域链的理解"><a href="#作⽤域和作⽤域链的理解" class="headerlink" title="作⽤域和作⽤域链的理解"></a>作⽤域和作⽤域链的理解</h1><h2 id="作⽤域"><a href="#作⽤域" class="headerlink" title="作⽤域"></a>作⽤域</h2><ul><li>在ES5中，全局是⼀个作⽤域，函数也会产⽣作⽤域。 </li><li>在ES6中，代码块、let、const等都会有属于⾃⼰的作⽤域。</li></ul><h2 id="作⽤域链"><a href="#作⽤域链" class="headerlink" title="作⽤域链"></a>作⽤域链</h2><ul><li>当进⼊到⼀个执⾏上下⽂时，执⾏上下⽂会关联⼀个作⽤域链。 </li><li>通常作⽤域链在解析时就被确定，作⽤域链与函数的定义位置有关，与它的调⽤位置⽆关</li></ul><h2 id="什么是变量提升、函数提升？"><a href="#什么是变量提升、函数提升？" class="headerlink" title="什么是变量提升、函数提升？"></a>什么是变量提升、函数提升？</h2><h3 id="变量提升："><a href="#变量提升：" class="headerlink" title="变量提升："></a>变量提升：</h3><ul><li><p>简单说就是在js代码执⾏前引擎会先进⾏预编译，预编译期间会将变量声明与函数声明提升⾄其对应作⽤域的最顶端，函数内声明的变量只会提升⾄该函数作⽤域最顶层。 </p></li><li><p>当函数内部定义的⼀个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端。</p></li><li><p>举个例⼦，如： </p><ul><li><pre><code>console.log(a); // undefinedvar a = 3; // 会将var a 的声明提升⾄最顶端</code></pre></li><li></li></ul></li></ul><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><ul><li>函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升。 </li><li>函数提升的优先级⼤于变量提升的优先级，即函数提升在变量提升之上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this绑定</title>
      <link href="/2023/02/14/this%E7%BB%91%E5%AE%9A/"/>
      <url>/2023/02/14/this%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h1><h2 id="this的绑定规则有⼏种？"><a href="#this的绑定规则有⼏种？" class="headerlink" title="this的绑定规则有⼏种？"></a>this的绑定规则有⼏种？</h2><ul><li>默认绑定：独⽴函数调⽤，函数没有被绑定到某个对象上进⾏调⽤ </li><li>隐式绑定：通过某个对象发起的函数调⽤，在调⽤对象内部有⼀个对函数的引⽤。 </li><li>显式绑定：明确this指向的对象，第⼀个参数相同并要求传⼊⼀个对象。 <ul><li>apply&#x2F;call </li><li>bind</li></ul></li><li>new绑定： <ul><li>创建⼀个全新对象 </li><li>新对象被执⾏prototype链接 </li><li>新对象绑定到函数调⽤的this </li><li>如果函数没有返回其他对象，表达式会返回这个对象</li></ul></li></ul><h2 id="this的⾯试题解析"><a href="#this的⾯试题解析" class="headerlink" title="this的⾯试题解析"></a>this的⾯试题解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.foo1 = function () &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line">this.foo2 = () =&gt; console.log(this.name);</span><br><span class="line">this.foo3 = function () &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line">this.foo4 = function () &#123;</span><br><span class="line">return () =&gt; &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;person1&quot;);</span><br><span class="line">var person2 = new Person(&quot;person2&quot;);</span><br><span class="line">// person1.foo1() // person1 隐式调⽤</span><br><span class="line">// person1.foo1.call(person2) // person2 显示调⽤ this指向person2所在的对象</span><br><span class="line">// person1.foo2(); // person1 箭头函数 向上层作⽤查找 上层作⽤域中的this为person1指向</span><br><span class="line">的对象</span><br><span class="line">// person1.foo2.call(person2); // person1 箭头函数 显示绑定没⽤</span><br><span class="line">// person1.foo3()() // window 相当于将返回的函数赋值给⼀个变量 指向该变量 是独⽴函数调⽤</span><br><span class="line">// person1.foo3.call(person2)() // window 默认调⽤</span><br><span class="line">// person1.foo3().call(person2) // person2 将函数的this显示绑定到person2所在的对象</span><br><span class="line">// person1.foo4()() // person1 箭头函数 向上层作⽤域中查找this foo4中的this隐式绑定为</span><br><span class="line">person1</span><br><span class="line">// person1.foo4.call(person2)() // person2 箭头函数 向上层作⽤域中查找this foo4中</span><br><span class="line">的this显示绑定为person2</span><br><span class="line">// person1.foo4().call(person2) // person1 箭头函数显示绑定没⽤和person1.foo4()相同</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>a标签下载文件</title>
      <link href="/2023/02/14/a%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2023/02/14/a%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="点击-a-标签下载⽂件如何做？"><a href="#点击-a-标签下载⽂件如何做？" class="headerlink" title="点击 a 标签下载⽂件如何做？"></a>点击 a 标签下载⽂件如何做？</h1><h1 id="有两种⽅式"><a href="#有两种⽅式" class="headerlink" title="有两种⽅式:"></a>有两种⽅式:</h1><p>a.download 当指定 a 标签的 download 属性时，点击该链接会直接保存为⽂件，⽂件名为 </p><p>download 属性 </p><p>通过对 a 标签指定的 URL 在服务器设置响应头 Content-Disposition: attachment; </p><p>filename&#x3D;”filename.jpg” 可直接下载</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> a标签下载文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element与Node区别</title>
      <link href="/2023/02/14/Element%E4%B8%8ENode%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/14/Element%E4%B8%8ENode%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM-中-Element-与-Node-有何区别"><a href="#DOM-中-Element-与-Node-有何区别" class="headerlink" title="DOM 中 Element 与 Node 有何区别"></a>DOM 中 Element 与 Node 有何区别</h1><p>Element 继承于 Node，具有 Node 的⽅法，同时⼜拓展了很多⾃⼰的特有⽅法。 </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element与Node区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不可复制</title>
      <link href="/2023/02/14/%E4%B8%8D%E5%8F%AF%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/02/14/%E4%B8%8D%E5%8F%AF%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现⻚⾯⽂本不可复制"><a href="#如何实现⻚⾯⽂本不可复制" class="headerlink" title="如何实现⻚⾯⽂本不可复制"></a>如何实现⻚⾯⽂本不可复制</h1><p>有 CSS 和 JS 两种⽅法，以下任选其⼀或结合使⽤ </p><h3 id="使⽤-CSS-如下："><a href="#使⽤-CSS-如下：" class="headerlink" title="使⽤ CSS 如下："></a>使⽤ CSS 如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user-select: none;</span><br></pre></td></tr></table></figure><p>或使⽤ JS 如下，监听 selectstart 事件，禁⽌选中。 </p><p>当⽤户选中⼀⽚区域时，将触发 selectstart 事件，Selection API 将会选中⼀⽚区域。禁⽌选中区域 </p><p>即可实现⻚⾯⽂本不可复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.body.onselectstart = (e) =&gt; &#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line">document.body.oncopy = (e) =&gt; &#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不可复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prefetch和preload应用场景</title>
      <link href="/2023/02/14/prefetch%E5%92%8Cpreload%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/02/14/prefetch%E5%92%8Cpreload%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="preload和prefetch的应⽤场景？"><a href="#preload和prefetch的应⽤场景？" class="headerlink" title="preload和prefetch的应⽤场景？"></a>preload和prefetch的应⽤场景？</h1><h2 id="1-webpack优化之preload和prefetch："><a href="#1-webpack优化之preload和prefetch：" class="headerlink" title="1.webpack优化之preload和prefetch："></a>1.webpack优化之preload和prefetch：</h2><p>单⻚⾯应⽤由于⻚⾯过多，可能会导致代码体积过⼤，从⽽使得⾸⻚打开速度过慢。所以切分代码，优化⾸屏打开速度尤为重要。 </p><p>但是所有的技术⼿段都不是完美的。当我们切割代码后，⾸屏的js⽂件体积减少了好多。但是也有⼀个突出的问题： </p><p>那就是当跳转其他⻚⾯的时候，需要下载相应⻚⾯的js⽂件，这就导致体验极其不好，每⼀次点击访问 </p><p>新⻚⾯都要等待js⽂件下载，然后再去请求接⼝获取数据。频繁出现loading动画的体验真的不好 </p><p>所以如果我们在进⼊⾸⻚后，在浏览器的空闲时间提前下好⽤户可能会点击⻚⾯的js⽂件，这样⾸屏的js </p><p>⽂件⼤⼩得到了控制，⽽且再点击新⻚⾯的时候，相关的js⽂件已经下载好了，就不再会出现loading动画</p><h2 id="2-动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间"><a href="#2-动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间" class="headerlink" title="2.动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间"></a>2.动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间</h2><p>按引⼊情况加载，只需添加注释即可 </p><ul><li>代码分割注释：&#x2F;webpackChunkName: ‘mp-supports’&#x2F; </li><li>prefetch注释：&#x2F;* webpackPrefetch: true *&#x2F;</li></ul><p>更多的，可以查看 webpack 注释⿊魔法：<a href="https://webpack.js.org/api/module-methods/#magic-comments">https://webpack.js.org/api/module-methods/#magic-comments</a></p><p>以下便是使用案列:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123; default: lodash &#125; = await import(/* webpackChunkName: &quot;lodash&quot; */ /*</span><br><span class="line">webpackPrefetch: true */ &#x27;lodash&#x27;);</span><br><span class="line">// Multiple possible targets</span><br><span class="line">import(</span><br><span class="line">/* webpackInclude: /\.json$/ */</span><br><span class="line">/* webpackExclude: /\.noimport\.json$/ */</span><br><span class="line">/* webpackChunkName: &quot;my-chunk-name&quot; */</span><br><span class="line">/* webpackMode: &quot;lazy&quot; */</span><br><span class="line">/* webpackPrefetch: true */</span><br><span class="line">/* webpackPreload: true */</span><br><span class="line">`./locale/$&#123;language&#125;`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prefetch和preload应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prefetch和preload区别</title>
      <link href="/2023/02/14/prefetch%E5%92%8Cpreload%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/14/prefetch%E5%92%8Cpreload%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="prefetch-与-preload-的区别是什么"><a href="#prefetch-与-preload-的区别是什么" class="headerlink" title="prefetch 与 preload 的区别是什么?"></a>prefetch 与 preload 的区别是什么?</h1><ul><li><p>先来看一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>preload 是⼀个声明式 fetch，可以强制浏览器在不阻塞 document 的 onload 事件的情况下请 </p><p>求资源。 preload 顾名思义就是⼀种预加载的⽅式，它通过声明向浏览器声明⼀个需要提前加载的资源，当资源真正被使⽤的时候⽴即执⾏，就⽆需等待⽹络的消耗 </p></li><li><p>prefetch 告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的。 </p><p>若能预测到⽤户的⾏为，⽐如懒加载，点击到其它⻚⾯等则相当于提前预加载了需要的资源。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prefetch和preload区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/14/json%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/02/14/json%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="说说JSON的相关⽤法和应⽤场景？"><a href="#说说JSON的相关⽤法和应⽤场景？" class="headerlink" title="说说JSON的相关⽤法和应⽤场景？"></a>说说JSON的相关⽤法和应⽤场景？</h1><h3 id="三种⽤法"><a href="#三种⽤法" class="headerlink" title="三种⽤法"></a>三种⽤法</h3><p>简单值: 数字 字符串 布尔类型 </p><p>对象值 key value组成 必须添加双引号 value 可以是简单值 对象值 数组值 </p><p>数组值 内容可以是对象值 简单值 数组值</p><h3 id="应⽤场景"><a href="#应⽤场景" class="headerlink" title="应⽤场景"></a>应⽤场景</h3><p>⽹络传输的JSON数据 </p><p>项⽬的某些配置⽂件 </p><p>⾮关系型数据库将JSON作为存储⽂件</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>load和DOMcontentLoaded区别</title>
      <link href="/2023/02/14/load%E5%92%8CDOMcontentLoaded%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/14/load%E5%92%8CDOMcontentLoaded%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>load </p><ul><li>浏览器加载完所有的HTML 还加载完所有的外部资源 样式 图⽚等</li></ul><p>DOMContentLoaded </p><ul><li>HTML⽂档所有资源都加载完成 并构建了DOM树 但是⼀些外部资源还没有加载完成 如图⽚的src</li></ul><h3 id="事件委托的理解"><a href="#事件委托的理解" class="headerlink" title="事件委托的理解?"></a>事件委托的理解?</h3><p>利⽤事件的冒泡机制，以及事件对象中可以准确获知触发事件的元素机制(e.target)，将⼦元素事件委托 </p><p>给⽗元素处理的现象</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> load和DOMcontentLoaded区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件委托</title>
      <link href="/2023/02/14/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2023/02/14/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>利⽤事件的冒泡机制，以及事件对象中可以准确获知触发事件的元素机制(e.target)，将⼦元素事件委托 </p><p>给⽗元素处理的现象。 </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡事件</title>
      <link href="/2023/02/14/%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/02/14/%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡和事件捕获的理解"><a href="#冒泡和事件捕获的理解" class="headerlink" title="冒泡和事件捕获的理解"></a>冒泡和事件捕获的理解</h1><p>事件冒泡: </p><ul><li>从最内层的元素向外依次传递的顺序, 默认是事件冒泡</li></ul><p>事件捕获: </p><ul><li>从外层到内层依次传递的顺序 ,可以通过addEventListener(“click”,fn,true) 监听事件捕获</li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>attributy和Property</title>
      <link href="/2023/02/14/attributy%E5%92%8CProperty/"/>
      <url>/2023/02/14/attributy%E5%92%8CProperty/</url>
      
        <content type="html"><![CDATA[<h1 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h1><ul><li>浏览器解析HTML元素时 会将对应的属性(attribute)放在对应的元素对象上 </li><li>具体分为标准的属性和⾮标准的属性 <ul><li>标准属性: id class href type value等等 </li><li>⾮标准属性(⾃定义) :abc age height</li></ul></li></ul><h1 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h1><ul><li>对于标准的attribute 会在DOM对象上创建对应的property属性 </li><li>⼤多数情况下 他们是相互作⽤的 改变其中⼀个 另⼀个也会随之改变 </li><li>⼤多数情况 推荐获取attribute 使⽤property⽅式 因为它默认是有类型的</li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> attributy和Property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑与&amp;&amp;和逻辑或||的本质和区别？</title>
      <link href="/2023/02/14/%E9%80%BB%E8%BE%91%E4%B8%8E&amp;&amp;%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2023/02/14/%E9%80%BB%E8%BE%91%E4%B8%8E&amp;&amp;%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑与-也叫作短路与"><a href="#逻辑与-也叫作短路与" class="headerlink" title="逻辑与:也叫作短路与"></a>逻辑与:也叫作短路与</h1><ul><li>从左往右,依次计算 </li><li>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较 </li><li>true ,继续下⼀个⽐较 </li><li>false ,直接返回该运算元的初始值 </li><li>如果找到最后也没有找到,就返回最后⼀个运算元</li></ul><h1 id="逻辑或-也叫做短路或"><a href="#逻辑或-也叫做短路或" class="headerlink" title="逻辑或:也叫做短路或"></a>逻辑或:也叫做短路或</h1><p>从左往右,依次计算 </p><p>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较 </p><p>true ,直接返回该运算元的初始值 </p><p>false ,继续下⼀个⽐较 </p><p>如果找到最后也没有找到,就返回最后⼀个运算元</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==和===</title>
      <link href="/2023/02/14/==%E5%92%8C===/"/>
      <url>/2023/02/14/==%E5%92%8C===/</url>
      
        <content type="html"><![CDATA[<h1 id="x3D-x3D-普通相等"><a href="#x3D-x3D-普通相等" class="headerlink" title="&#x3D;&#x3D; (普通相等)"></a>&#x3D;&#x3D; (普通相等)</h1><p>在类型不相同的情况下, 会将运算元先转成Number的值, 再进⾏⽐较(隐式转换) </p><p>null⽐较特殊: null在进⾏⽐较的时候, 应该是会被当成⼀个对象和原⽣类型进⾏⽐较的 </p><h1 id="x3D-x3D-x3D-严格不等"><a href="#x3D-x3D-x3D-严格不等" class="headerlink" title="&#x3D;&#x3D;&#x3D; (严格不等)"></a>&#x3D;&#x3D;&#x3D; (严格不等)</h1><p>在类型不同的情况下,直接返回false</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型</title>
      <link href="/2023/02/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/02/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-中的常⻅数据类型"><a href="#JavaScript-中的常⻅数据类型" class="headerlink" title="JavaScript 中的常⻅数据类型"></a>JavaScript 中的常⻅数据类型</h1><h3 id="Number-gt-代表数据类型是数值"><a href="#Number-gt-代表数据类型是数值" class="headerlink" title="Number -&gt; 代表数据类型是数值"></a>Number -&gt; 代表数据类型是数值</h3><ul><li><p>整数 </p></li><li><p>浮点</p></li><li><p>数组</p></li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>String -&gt; 代表字符串类型 -&gt; 通常是⼀段⽂本</li></ul><h3 id="boolean-gt-布尔类型"><a href="#boolean-gt-布尔类型" class="headerlink" title="boolean -&gt; 布尔类型"></a>boolean -&gt; 布尔类型</h3><ul><li>true </li><li>false</li></ul><p>NULL -&gt; 空值 </p><p>undefifined -&gt; 变量未定义 </p><p>Object -&gt; 对象类型 </p><p>BigInt -&gt; ⼤整数类型 </p><p>Symbol -&gt; 符号类型</p>]]></content>
      
      
      <categories>
          
          <category> js数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常⻅的节点（Node）属性</title>
      <link href="/2023/02/14/%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/"/>
      <url>/2023/02/14/%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>nodeType </p><ul><li><p>获取节点的类型 </p></li><li><p>⽐如 注释节点8 ⽂本节点3 元素节点1</p></li></ul></li><li><p>tagName </p><ul><li>获取元素的标签名词 仅适⽤于Element节点</li></ul></li><li><p>nodeName </p><ul><li>获取元素的标签名词 适⽤于任何Node节点</li></ul></li><li><p>innerHTML,textContent </p><ul><li>前者将元素中的HTML获取为字符串属性 后者仅仅获取⽂本内容</li></ul></li><li><p>outerHTML </p><ul><li>包含了完整的HTML </li><li>相当于innerHTML加上元素本身</li></ul></li><li><p>nodeValue&#x2F;data </p><ul><li>获取⾮元素节点的⽂本内容</li></ul></li><li><p>hidden </p><ul><li>⽤于设置元素隐藏(全局属性)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节点（Node) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调和匿名</title>
      <link href="/2023/02/14/%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8C%BF%E5%90%8D/"/>
      <url>/2023/02/14/%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8C%BF%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h1><h4 id="⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数"><a href="#⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数" class="headerlink" title="⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数"></a>⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数</h4><h1 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h1><h4 id="如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，"><a href="#如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，" class="headerlink" title="如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，"></a>如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，</h4><h4 id="那么这个函数称之为匿名函数"><a href="#那么这个函数称之为匿名函数" class="headerlink" title="那么这个函数称之为匿名函数"></a>那么这个函数称之为匿名函数</h4>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回调和匿名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM和document对象的理解</title>
      <link href="/2023/02/14/DOM%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/02/14/DOM%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对DOM和document对象的理解"><a href="#对DOM和document对象的理解" class="headerlink" title="对DOM和document对象的理解"></a>对DOM和document对象的理解</h1><h2 id="DOM-⽂档对象模型-Document-Object-Model-将⻚⾯所有的内容表示为可以修改的对象"><a href="#DOM-⽂档对象模型-Document-Object-Model-将⻚⾯所有的内容表示为可以修改的对象" class="headerlink" title="DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象"></a>DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象</h2><ul><li><p>浏览器将我们编写在HTML中的每⼀个元素(Element)都抽象成了⼀个个对象 </p></li><li><p>所有这些对象都可以通过JavaScript来对其进⾏访问，那么我们就可以通过JavaScript来操作 </p></li><li><p>⻚⾯; </p></li><li><p>所以，我们将这个抽象过程称之为 ⽂档对象模型(Document Object Model)</p></li><li><p>Document节点表示的整个载⼊的⽹⻚，它的实例是全局的document对象:对DOM的所有操作都是从 document 对象开始的 </p></li><li><p>它是DOM的⼊⼝点，可以从document开始去访问任何节点元素;</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM和document对象的理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object_CSD</title>
      <link href="/2023/02/12/Object-CSD/"/>
      <url>/2023/02/12/Object-CSD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据及结构与对象"><a href="#数据及结构与对象" class="headerlink" title="数据及结构与对象"></a>数据及结构与对象</h1><p>Math[PI] </p><p>此种语法，中括号里面是一个表达式 表达式计算结果应该是一个字符串 该字符串被当做要读取的属性的名 整个表达式返回该属性的属性值  </p><p>Math[“PI”]</p><p>Math[‘P’+’I’]</p><p>x&#x3D;”PI”</p><p>Math[x]</p><p>是可以的</p><p>&#x2F;&#x2F; 数组是值的“有序”集合</p><p> &#x2F;&#x2F; 对象是值的“具名”集合 </p><p>&#x2F;&#x2F; 在数组中，我们为值编号 </p><p>&#x2F;&#x2F; 在对象中，我们为值起名 </p><p>&#x2F;&#x2F; 有些语言里，对象又叫关联数组 </p><p>&#x2F;&#x2F;   把值与名字“关联”起来 </p><p>JS中一切皆对象（除空值以外）</p><p>因为一切都能读出属性</p><p>因为对于任何一个值来说，以下表达式都不报错</p><p>在其它很多语言里，能读出属性的只有对象</p><p>从能否可再拆分的角度讲，原始类型不算对象</p><p>但从能否读取属性的角度讲，原始类型也算对象，因为它们能读出属性</p><p>x &#x3D; 2</p><p>x.toFixed()</p><p>y &#x3D; ‘owiejfo’</p><p>y.length</p><p>y.toUpperCase()</p><p>z &#x3D; true</p><p>z.toString()</p><blockquote><p>c&#x3D;&#x3D; a&#x2F;&#x2F;相等运算判断对象时，返回的是两边是否是同一个对象<br>&#x2F;&#x2F;而判断原始类型时工返回的是两边的值是否相同</p></blockquote><p>为了找出对象具有的属性，可以使用 Object.keys 函数。 </p><p>你给它一个对象，它返回一个字符 </p><p>串数组 - 对象的属性名称</p><p>console.log(Object.keys({x: 0, y: 0, z: 2})); </p><p>&#x2F;&#x2F; → [“x”, “y”, “z”]</p><p><strong>Object.assign（）</strong> 方法将所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>（ 返回 true）和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">自有</a>（ 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。 </p><p>实列一</p><p>let objectA &#x3D; {a: 1, b: 2}; </p><p>Object.assign(objectA, {b: 3, c: 4}); </p><p>console.log(objectA); </p><p>&#x2F;&#x2F; → {a: 1, b: 3, c: 4} </p><p>实列二</p><p>const target &#x3D; { a: 1, b: 2 };<br>const source &#x3D; { b: 4, c: 5 };</p><p>const returnedTarget &#x3D; Object.assign(target, source);</p><p>console.log(target);<br>&#x2F;&#x2F; expected output: Object { a: 1, b: 4, c: 5 }</p><p>console.log(returnedTarget);<br>&#x2F;&#x2F; expected output: Object { a: 1, b: 4, c: 5 }</p><p>copyWithin（0，3，6）将3-6复制到前面</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/2023/02/12/Array/"/>
      <url>/2023/02/12/Array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h1><p>数组是值的有序集合</p><p>元素在数组中从0开始编号</p><p>创建数组 var a &#x3D; [1,2,3]</p><p>创建数组 var a &#x3D; Array(6) 创建长度为6的数组</p><p>创建数组 var a &#x3D; Array(6).fill(0) 创建长度为6的数组</p><p>创建数组 var a &#x3D; Array(6,5,4,3) 创建由6，5，4，3组成的数组</p><p>获取数组的长度 a.length</p><p>获取数组中的元素 a[i] ，i是元素在数组中的编号&#x2F;索引&#x2F;下标，下标只有整数</p><p>a[表达式]，，表达式计算出一个整数，</p><p>这个整体也是一个表达式，求值结果为数组中的某一项</p><p>a[i] &#x3D; 8 向数组的第i项赋值，之前的值就被扔了</p><p>任意值都可以放入数组中，如null，undefined，2，3，5，”owiefj”, true，函数，数组（因为数组本身也是值）</p><p>向数组末尾添加一个元素： a.push(1) 返回数组新的长度</p><p>向数组末尾添加多个元素： a.push(1,2,3,4) 返回数组新的长度</p><p>从数组的末尾删除并返回元素 var result &#x3D; a.pop()</p><p>向数组的开头添加一个元素 a.unshift(1) 返回数组新的长度</p><p>向数组的开头添加多个元素 a.unshift(1,2,3,4) 返回数组新的长度</p><p>从数组的开头删除并返回元素 var result &#x3D; a.shift()</p><p>将数组的内容填充为某个值 a.fill(5) 将数组所有的值都填成5</p><p>读取数组不存在的下标会得到undefined</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2023/02/12/Map/"/>
      <url>/2023/02/12/Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Map的封装"><a href="#Map的封装" class="headerlink" title="Map的封装"></a>Map的封装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">class Map2 &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">    this._keys = [] // 用来存储每组映射的key</span><br><span class="line"></span><br><span class="line">    this._vals = [] // 用来存储每组映射的val</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return this._vals[keyIdx]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123; // 判断映射中是否存在某个key的映射</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123; // 设置key的映射目标为val</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this._vals[keyIdx] = val</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      this._keys.push(key)</span><br><span class="line"></span><br><span class="line">      this._vals.push(val)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete(key) &#123; // 删除key的映射对</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this._keys.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      this._vals.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123; // 清空所有的映射</span><br><span class="line"></span><br><span class="line">    this._keys = []</span><br><span class="line"></span><br><span class="line">    this._vals = []</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // size() &#123; // 返回当前Map中映射对的数量</span><br><span class="line"></span><br><span class="line">  //   return this._keys.length</span><br><span class="line"></span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Map3 &#123;</span><br><span class="line"></span><br><span class="line">  #keys = [] // private class field</span><br><span class="line"></span><br><span class="line">  #vals = [] // private class field</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return this.#vals[keyIdx]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123; // 判断映射中是否存在某个key的映射</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123; // 设置key的映射目标为val</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this.#vals[keyIdx] = val</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      this.#keys.push(key)</span><br><span class="line"></span><br><span class="line">      this.#vals.push(val)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete(key) &#123; // 删除key的映射对</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this.#keys.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      this.#vals.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123; // 清空所有的映射</span><br><span class="line"></span><br><span class="line">    this.#keys = []</span><br><span class="line"></span><br><span class="line">    this.#vals = []</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123; // 返回当前Map中映射对的数量</span><br><span class="line"></span><br><span class="line">    return this.#keys.length</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class Stack &#123;</span><br><span class="line"></span><br><span class="line">  #size = 0</span><br><span class="line"></span><br><span class="line">  #top = null // 用于存储栈内元素的链表的头结点，由于头结点是栈顶，所以起名top</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 将元素val放入栈顶</span><br><span class="line">push(val) &#123;</span><br><span class="line">  var node = &#123;</span><br><span class="line">    val: val,</span><br><span class="line">    next: this.#top,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.#top = node</span><br><span class="line">  this.#size++</span><br><span class="line"></span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 返回栈顶元素并将其出栈</span><br><span class="line">pop() &#123;</span><br><span class="line">  if (this.#top) &#123;</span><br><span class="line">    var result = this.#top.val</span><br><span class="line">    this.#top = this.#top.next</span><br><span class="line">    this.#size--</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查看栈顶元素的值，但不让它出栈</span><br><span class="line">peek() &#123;</span><br><span class="line">  if (this.#top) &#123;</span><br><span class="line">    return this.#top.val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line">  return this.#size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 使用链表实现队列的抽象数据结构<br>  class Queue {<br>    constructor() {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进队</span><br><span class="line">enqueue(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 出队，将队头元素返回并从队列里删除</span><br><span class="line">dequeue() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 查看队头元素的值</span><br><span class="line">peek() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 表示一个集合：不重复的无序元素组成东西。<br>  class Group {<br>    constructor() {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">// 为集合中添加一个元素</span><br><span class="line">add(val) &#123;</span><br><span class="line"></span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 返回集合中是否有val这个元素</span><br><span class="line">has(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 从集合中删除val元素，返回是否删除成功</span><br><span class="line">delete(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 二维向量<br>  class Vector {<br>    constructor(x, y) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">// 用当前向量加上一个向量v，返回新的结果向量</span><br><span class="line">plus(v) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 用当前向量减去一个向量v，返回新的结果向量</span><br><span class="line">minus(v) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 实现复数及其四则运算<br>  class Complex {<br>    constructor(real, imag) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">plus(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">minus(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mul(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">divide(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以 (3+2j) 的形式返回复数的字符串形式</span><br><span class="line">toString() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  var c1 &#x3D; new Complex(2, 3)<br>  var c2 &#x3D; new Complex(5, -1)<br>  var c3 &#x3D; c1.mul(c2)</p><p></script></p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdom</title>
      <link href="/2023/02/12/JSDom/"/>
      <url>/2023/02/12/JSDom/</url>
      
        <content type="html"><![CDATA[<p>元素的查找：<br>  getElements?.*()</p><p>元素的周围指针：<br>  el.firstChild&#x2F;lastChild&#x2F;nextSibiling&#x2F;previousSibiling<br>  el.parentNode&#x2F;parentElement<br>  el.firstElementChild&#x2F;lastElementChild<br>  el.nextElementSibiling&#x2F;previousElementSibiling<br>  el.childNodes&#x2F;children</p><p>元素的常用方法：<br>  对结点进行增删改<br>  el.appendChild(node)<br>  el.removeChild(node)<br>    node.remove()<br>  el.replaceChild(node, baseNode)<br>    baseNode.replaceWith(node)<br>  el.insertBefore(node, baseNode)</p><p>attr&amp;prop：<br>  node.xxxxx   dom property<br>  标准属性大都可以使用node.prop的形式访问,如<br>    id,title,alt,src,href,type,name,value<br>    class要用className,label的for属性要用htmlFor<br>  node.get&#x2F;set&#x2F;remove&#x2F;hasAttribute()   html attribute</p><p>新浏览器的一些方便的dom功能:<br>  el.classList.add&#x2F;remove&#x2F;replace&#x2F;toggle&#x2F;contains 访问及操作元素的class<br>  el.dataset.xxxYyyy 访问data-属性<br>  el.remove() 删除元素自身<br>    el.parentElement.removeChild(el)<br>  el.replaceWith(targetNode) 用targetNode替换el<br>  el.append(string, node, node, string, …)<br>  el.prepend(string, node, node, string, …)</p><p>  el.innerHTML 元素内部的结点的html表示,也可以赋值<br>  el.innerText 元素内部的文本内容,会受css影响<br>  el.textContent 元素内部的文本结点的值按顺序拼接得到的内容<br>  el.outerHTML 包含元素自身及内部的结点的html表示,也可以赋值,赋值会替换掉这个元素<br>    相当于在innerHTML的结果前后加上元素自身的开始和结束标签<br>  el.outerText 读取时等价于innerText,赋值时相当于用字符串替换该结点</p><p>function getInnerHTML(node) {</p><p>  var result &#x3D; ‘’<br>  for (var child of node.childNodes) {<br>      result +&#x3D; getOuterHTML(child)<br>  }<br>  return result</p><p>}</p><p>function getInnerHTML(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var result &#x3D; ‘’<br>    for (var child of node.childNodes) {<br>      if (child.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>        result +&#x3D; getInnerHTML(child)<br>      } else<br>        result +&#x3D; <code>&lt;$&#123;child.tagName&#125;&gt;</code> + getInnerHTML(child) + <code>&lt;/$&#123;child.tagName&#125;&gt;</code><br>    }<br>    return result<br>  }<br>}</p><p>function getTextContent(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var start &#x3D; &#96;&#96;<br>    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) {<br>      start +&#x3D; getTextContent(node.childNodes[i])<br>    }<br>    return start<br>  }<br>}</p><p>function getOuterHTML(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var tagName &#x3D; node.tagName.toLowerCase()<br>    var start &#x3D; <code>&lt;$&#123;tagName&#125;&gt;</code><br>    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) {<br>      start +&#x3D; getOuterHTML(node.childNodes[i])<br>    }<br>    return start + <code>&lt;/$&#123;tagName&#125;&gt;</code><br>  }<br>}</p><p>&#x2F;&#x2F; node.getElementsByTagName(tagName)<br>&#x2F;&#x2F; getElementsByTagName(node, tagName)</p><p>function getElementsByTagName(node, tagName) {<br>  var result &#x3D; []<br>  for (var child of node.children) {<br>    if (child.tagName &#x3D;&#x3D; tagName) {<br>      result.push(child)<br>    }<br>    result.push(…getElementsByTagName(child, tagName))<br>  }<br>  return result<br>}</p><p>function getElementsByTagName(node, tagName) {<br>  var result &#x3D; []<br>  &#x2F;&#x2F; 先序遍历node为根结点的dom树<br>  traverseDOM(node, it &#x3D;&gt; {<br>    &#x2F;&#x2F; 遇到的每个结点,如果是要找的标签名,则push到结果里<br>    if (it.tagName &#x3D;&#x3D; tagName) {<br>      result.push(it)<br>    }<br>  })<br>  &#x2F;&#x2F; 结果是一定不能包含根结点的<br>  &#x2F;&#x2F; 如果根结点在结果里,那么一定在第0项<br>  if (result[0] &#x3D;&#x3D; node) {<br>    result.shift()<br>  }<br>  return result<br>}</p><p>function traverseDOM(node, action &#x3D; console.log) {<br>  if (node.nodeType &#x3D;&#x3D; document.ELEMENT_NODE) {<br>    action(node)<br>    for (var child of node.children) {<br>      traverseDOM(child, action)<br>    }<br>  }<br>}</p><p>&#x2F;&#x2F; 带提前结束功能的遍历函数,让action返回false以提前结束<br>function traverseDOM(node, action &#x3D; console.log) {<br>  if (node.nodeType &#x3D;&#x3D; document.ELEMENT_NODE) {<br>    if (action(node) &#x3D;&#x3D;&#x3D; false) {<br>      return false<br>    }<br>    for (var child of node.children) {<br>      if (traverseDOM(child, action) &#x3D;&#x3D;&#x3D; false) {<br>        return false<br>      }<br>    }<br>  }<br>}</p><p>function getElementById(id, node &#x3D; document.documentElement) {<br>  if (node.id &#x3D;&#x3D;&#x3D; id) {<br>    return node<br>  } else {<br>    for (var child of node.children) {<br>      var result &#x3D; getElementById(id, child)<br>      if (result) {<br>        return result<br>      }<br>    }<br>    return null<br>  }<br>}</p><p>function getElementById(id) {<br>  var result &#x3D; null<br>  try {<br>    traverseDOM(document.documentElement, it &#x3D;&gt; {<br>      if (it.id &#x3D;&#x3D;&#x3D; id) {<br>        result &#x3D; it<br>        throw 2<br>      }<br>    })<br>  } catch (e) {<br>    if (e &#x3D;&#x3D;&#x3D; 2) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span><br><span class="line">  throw e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }<br>  return result<br>}<br>function getElementById(id) {<br>  var result &#x3D; null<br>  traverseDOM(document.documentElement, it &#x3D;&gt; {<br>    if (it.id &#x3D;&#x3D;&#x3D; id) {<br>      result &#x3D; it<br>      return false<br>    }<br>  })<br>  return result<br>}</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2023/02/11/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2023/02/11/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex:"></a>flex:</h1><p>大号的行内布局</p><h3 id="外层元素-flex-container-flex-容器"><a href="#外层元素-flex-container-flex-容器" class="headerlink" title="外层元素: flex container flex 容器"></a>外层元素: flex container flex 容器</h3><p>flex 窗口的子元素: flex item flex 元素</p><ul><li><p>flex-wrap:wrap 折行</p></li><li><p>flex-grow:0; &#x2F;_ 扩张权重_&#x2F;宽度的权重 默认为 0</p></li><li><p>flex-grow:0.x; &#x2F;<em>按照百分比获取剩余空间</em>&#x2F; 所有求和不超过 100%也就是 1 生效</p></li><li><p>flex-shrink:; &#x2F;<em>收缩系数</em>&#x2F; 默认 1</p></li><li><ul><li><p>不是 flex item 的 flex 父元素从外面看就像块元素一样<br>如宽度会打满包含块<br>但是子元素的 margin 不会超出去<br>但是相邻的元素垂直方向的 margin 还是会合并的</p></li><li><p>收缩或者扩张都不会让元素超出自己 min-w&#x2F;h 以及 max-w&#x2F;h 设定 的尺寸<br>收缩不能收到比自己的 min-width 还小<br>扩张不能扩张到比自己的 max-width 还大<br>收缩只发生在不折行的时候<br>因为如果折行就不可能存在空间不够的情况<br>flex 父元素”垂直”方向上的额外空间,只会均等的分配给每一行<br>当高度固定了如果还有额外空间用 height:auto;会自动分配填满</p></li></ul><h3 id="flex-父元素用来调用子元素摆放属性-justify-content"><a href="#flex-父元素用来调用子元素摆放属性-justify-content" class="headerlink" title="flex 父元素用来调用子元素摆放属性 justify-content"></a>flex 父元素用来调用子元素摆放属性 justify-content</h3><pre><code>* justify-content  设定一&quot;行&quot;的元素在行中的&quot;水平&quot;分布 start 项目与容器的左侧对齐。 end 项目与容器的右侧对齐 center 项目在容器的中心对齐 space-between 项目以相等的间距显示。 space-around 项目以等间距显示 space-evenly 平均分配物品</code></pre><p>项目在它们周围有相等的空间</p></li></ul><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>设定一”行”的元素在行中的”垂直”分布<br>start 项目与容器顶部对齐</p><p>end 项目与容器底部对齐</p><p>center 项目在容器的垂直中心对</p><p>baseline 项目显示在容器的基线处</p><p>stretch 物品被拉伸以适合容器</p><ul><li><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>​ 设定所有行(“行们”)在父元素垂直方向的分布<br>(设置父元素垂直方向上额外空间的分配)</p><pre><code> start flex-start: 线装在容器的顶部 end flex-end: 线装在容器的底部 center center: 线在容器的垂直中心包装 space-between：行以相等的间距显示 两边对齐   space-around  行以相等的间距显示在它们周围 space-evenly平均分配物品   项目在它们周围有相等的空间   stretch(额外空间均分给每一行)：线条被拉伸以适合容器   flex父元素&quot;垂直&quot;方向上的额外空间,只会均等的分配给每一行 * 不是flex item的flex父元素从外面看就像块元素一样如宽度会打满包含块   但是子元素的margin不会超出去   但是相邻的元素垂直方向的margin还是合并的</code></pre></li></ul><h3 id="flex-子元素用来调整自身摆放属性"><a href="#flex-子元素用来调整自身摆放属性" class="headerlink" title="flex 子元素用来调整自身摆放属性"></a>flex 子元素用来调整自身摆放属性</h3><pre><code>   align-self 类似align-items,但是只调整自己   order 调整自己的显示顺序(不是层叠顺序)   flex子元素不用定位就可以使用z-index属性  flex: 在一个属性上直接设置flex子元素的flex-grow flex-shrink flex-basis</code></pre><ul><li><p>flex: auto;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: auto;</code></pre></li><li><p>flex: 1;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: 0%;</code></pre></li><li><p>flex: 0;</p><pre><code>flex-grow: 0;flex-shrink: 1;flex-basis: 0%;</code></pre></li><li><p>flex: 100px;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: 100px;</code></pre></li><li><ul><li><p>flex-basis: 设定元素在主轴方向上的初始尺寸<br>当主轴水平时，它相当于 width</p><p>当主轴垂直时，它相当于 height</p><p>当它与 width&#x2F;height 一起用的时候，如果 flex-basis 的<br>值不为 auto，则它更优先</p></li></ul></li></ul><h3 id="flex-父元素的轴向-flex-direction"><a href="#flex-父元素的轴向-flex-direction" class="headerlink" title="flex 父元素的轴向:flex-direction"></a>flex 父元素的轴向:flex-direction</h3><pre><code>flex-direction: 设定主轴方向row 向右 项目的放置与文本方向相同row-reverse 向左 项目放置在与文本方向相反的位置column 向下 项目从上到下放置column-reverse 向上  项目从下到上放置</code></pre><h3 id="flex-wrap-设定交叉轴方向-交叉轴肯定跟主轴是垂直的"><a href="#flex-wrap-设定交叉轴方向-交叉轴肯定跟主轴是垂直的" class="headerlink" title="flex-wrap 设定交叉轴方向,交叉轴肯定跟主轴是垂直的"></a>flex-wrap 设定交叉轴方向,交叉轴肯定跟主轴是垂直的</h3><p>wrap 垂直与主轴,向右或向下</p><ul><li><p>项目环绕到其他行 ，类似于折行</p></li><li></li><li><p>wrap-reverse 垂直与主轴,向左或向上</p></li><li><p>项目反向环绕到附加行。</p></li><li><p>nowrap 每个项目都适合一行</p></li><li><p>不设定交叉轴方向,即不折行,所有元素在同一行或同一列</p></li><li></li><li><p>flex-flow 在一个属性上直接设置 flex-direction 和<br>flex-wrap 换行</p><p>flex-flow: wrap column; 换行 向下 项目从上到下放置</p><p>flex-grow 设定主轴方向上额外空间的分配<br>flex-shrink 设定主轴方向上空间收缩的系数</p><h2 id="flex-flow-弹性容器"><a href="#flex-flow-弹性容器" class="headerlink" title="flex-flow 弹性容器"></a>flex-flow 弹性容器</h2><p>*_ &#x2F;_ flex-flow: &lt;’flex-direction’&gt; *&#x2F;</p><p>flex-flow: row; 向右 项目的放置与文本方向相同</p><p>flex-flow: row-reverse; 向左 项目放置在与文本方向相反的位置</p><p>flex-flow: column; 向下 项目从上到下放置</p><p>flex-flow: column-reverse; 设置反转</p><p>&#x2F;_ flex-flow: &lt;’flex-wrap’&gt; _&#x2F;</p><p>flex-flow: nowrap;</p><p>flex-flow: wrap; 换行</p><p>flex-flow: wrap-reverse;</p><p>&#x2F;_ flex-flow: &lt;’flex-direction’&gt; and &lt;’flex-wrap’&gt; _&#x2F;</p><p>flex-flow: row nowrap;</p><p>flex-flow: column wrap;</p><p>flex-flow: column-reverse wrap-reverse;</p><p>&#x2F;_ Global values _&#x2F;</p><p>flex-flow: inherit;</p><p>flex-flow: initial;</p><p>flex-flow: revert;</p><p>flex-flow: revert-layer;</p><p>flex-flow: unset;</p><p>​</p></li></ul><h4 id="flex-父元素中的匿名文本"><a href="#flex-父元素中的匿名文本" class="headerlink" title="flex 父元素中的匿名文本"></a>flex 父元素中的匿名文本</h4><pre><code>flex父元素中的匿名文本相当于将该文本包进一个标签但不给该标签设置任何属性但它会受到flex父元素 justify-content, align-items, align-content属性的影响flex子元素的的margin：auto会均等的分配额外的空间，但晚于flex-grow对空间的占用</code></pre><h2 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h2><pre><code>设置在flex父元素用于指定子元素之间的间隙gap: &lt;row-gap&gt; &lt;column-gap&gt;;row-gap:column-gap: 行内flex元素,外面看是行内,里面看是flexdisplay: inline-flex 定位flex元素,外面看是定位,里面看是flexdisplay: flex;position: absolute;浮动flex元素,外面看是浮动,里面看是flexdisplay: flex;float: left;</code></pre><p><img src="D:\Blog\source_posts\flex.jpg" alt="flex"></p>]]></content>
      
      
      <categories>
          
          <category> flex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
