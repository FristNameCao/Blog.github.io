<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回流与重绘</title>
      <link href="/2023/03/08/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
      <url>/2023/03/08/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<p>回流：是指浏览器需要重新计算元素位置和大小</p><p>重绘：是指浏览器需要重新计算背景颜色字体颜色，但是大小和位置没有发生变化</p><p>回流比重绘更耗费性能，因为回流会重新计算位置和大小，而重绘只需要重绘外观，比较快速</p><p>解决方案</p><ol><li>可以用CSS3动画替代JavaScript 动画，因为css3是运行在GPU 上而js是运行在CPU 上</li><li>避免频繁修改样式，我们可以把样式集中在一起，一次性修改，可以减少回流次数</li><li>避免频繁读取元素样式，因为读取元素样式也会触发回流，可以使用缓存或者批量读取方式来减少读取样式的次数</li><li>使用文档片段来减少DOM 操作，因为DOM 操作也会触发回流，使用文档片段可以将多次dom操作合并成一次操作，减少回流的次数</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回流与重绘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clear</title>
      <link href="/2023/03/01/clear/"/>
      <url>/2023/03/01/clear/</url>
      
        <content type="html"><![CDATA[<h1 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.clearfix：after&#123;</span><br><span class="line">    content:&#x27;&#x27;;</span><br><span class="line">    display:block;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">overflow:hidden</span><br></pre></td></tr></table></figure><h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><p>第一种模型是context-box，即width指定的是content区域宽度，而不是实际宽度，公式为</p><ul><li>实际宽度 &#x3D; width+padding+border</li></ul><p>第二种盒子模型是border-box，即width指定的左右边框外侧距离公式为</p><ul><li>实际宽度 &#x3D;width</li></ul><p>相同点都是用来指定宽度，不同点border-box更好用</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> clear和box </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>center</title>
      <link href="/2023/03/01/center/"/>
      <url>/2023/03/01/center/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS种居中方式"><a href="#CSS种居中方式" class="headerlink" title="CSS种居中方式"></a>CSS种居中方式</h2><ol><li>可以使用table固定高度 列tr 行td</li><li>可以使用div  把该div设置为display：table，然后给子标签设置display ：table-cell，vertical-align：middle</li><li>flex</li><li>绝对定位</li></ol>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> center </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC</title>
      <link href="/2023/03/01/BFC/"/>
      <url>/2023/03/01/BFC/</url>
      
        <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>bfc是什么回答（块级格式化上下文）</p><h2 id="怎么触发BFC？"><a href="#怎么触发BFC？" class="headerlink" title="怎么触发BFC？"></a>怎么触发BFC？</h2><ul><li>浮动元素(float)</li><li>绝对定位(元素position为absolute或者fiexd)</li><li>行内块inline block</li><li>overflow值不为visible（即是hidden或者auto）</li><li>弹性元素(display为flex或者inline-flex元素的直接子元素)</li></ul><h2 id="解决了什么问题？"><a href="#解决了什么问题？" class="headerlink" title="解决了什么问题？"></a>解决了什么问题？</h2><ol><li>清除浮动（为什么不用.clearfix呢）</li><li>防止margin合并</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>htmlyati</title>
      <link href="/2023/03/01/htmlyati/"/>
      <url>/2023/03/01/htmlyati/</url>
      
        <content type="html"><![CDATA[<h2 id="html语义化标签"><a href="#html语义化标签" class="headerlink" title="html语义化标签"></a>html语义化标签</h2><ol><li><p>是什么：语义化标签是一种写HTML标签的<strong>方法论</strong>&#x2F;方式</p></li><li><p>怎么做：实现方法是遇到标题就用h1到h6，遇到段落用p，遇到文章用article，主要内容用main，边栏用aside，导航用nav（就是找到中文对应的英文）</p></li><li><p>解决了什么问题：明确了html的书写方法论</p></li><li><p>优点:一适合搜索引擎检索；二，适合人类阅读，利于团队维护</p></li><li><p>缺点：没有</p></li><li><p>怎么解决缺点：无需解决</p><p>总结：是什么，怎么做，解决了什么问题，优点是、缺点是，怎么解决缺点</p></li></ol><p>HTML有哪些新标签</p><p>文章相关：header main footer nav section article figure mark</p><p>多媒体相关：video audio svg canvas</p><p>表单相关：type &#x3D; email    type &#x3D; tel</p><h2 id="Canvas和SVG的区别是什么？"><a href="#Canvas和SVG的区别是什么？" class="headerlink" title="Canvas和SVG的区别是什么？"></a>Canvas和SVG的区别是什么？</h2><ol><li>Canvas主要是用笔刷来绘制2D图形的</li><li>SVG主要用标签来绘制不规则的矢量图</li><li>相同点：都是用来画2D图形的</li><li>不同点：Canvas画的是位图，SVG画的是矢量图</li><li>不同点：SVG节点过多时渲染慢，Canvas性能更好一点，但是写起来更复杂</li><li>不同点：SVG支持分层和事件，Canvas不支持，但是可以用库实现</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> htmlyati </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期</title>
      <link href="/2023/03/01/vue%E7%94%9F%E5%91%BD/"/>
      <url>/2023/03/01/vue%E7%94%9F%E5%91%BD/</url>
      
        <content type="html"><![CDATA[<p>Vue 生命周期指的是 Vue 实例从创建到销毁的过程，Vue 生命周期包含了多个阶段，每个阶段都有对应的钩子函数可以在特定的时刻执行相应的操作。常用的 Vue 生命周期有以下几个阶段：</p><h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><p>在实例被创建之初，Vue 会先执行 beforeCreate 钩子函数。此时，Vue 实例的数据观测和事件机制都还未初始化，因此在此时不能访问到 data、computed、methods 等属性和方法，也不能访问到 DOM 元素等。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>在 beforeCreate 钩子函数执行之后，Vue 会执行 created 钩子函数。此时，Vue 实例已经完成了数据观测和事件机制的初始化，但是此时还未挂载到 DOM 上，因此无法访问到 DOM 元素。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>在 created 钩子函数执行之后，Vue 会执行 beforeMount 钩子函数。此时，Vue 实例已经完成了模板编译，但是还未将模板渲染成真实的 DOM 元素。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>在 beforeMount 钩子函数执行之后，Vue 会执行 mounted 钩子函数。此时，Vue 实例已经将模板渲染成真实的 DOM 元素，并且挂载到了页面上。mounted 钩子函数是常用的操作 DOM 元素和进行网络请求等操作的时机。</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>当 Vue 实例的数据发生变化时，Vue 会先执行 beforeUpdate 钩子函数。此时，Vue 实例还未重新渲染 DOM 元素。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>在 beforeUpdate 钩子函数执行之后，Vue 会执行 updated 钩子函数。此时，Vue 实例已经完成了重新渲染 DOM 元素的操作。</p><p>beforeDestroy</p><p>在 Vue 实例销毁之前，Vue 会先执行 beforeDestroy 钩子函数。此时，Vue 实例还未销毁，但是可以进行一些清理工作，比如清除定时器、取消事件监听等。</p><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>在 Vue 实例销毁之前，Vue 会先执行 beforeDestroy 钩子函数。此时，Vue 实例还未销毁，但是可以进行一些清理工作，比如清除定时器、取消事件监听等。</p><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>在 beforeDestroy 钩子函数执行之后，Vue 会执行 destroyed 钩子函数。此时，Vue 实例已经完成了销毁操作，所有的事件监听和定时器等资源都已经被清除。此时无法再访问 Vue 实例的属性和方法。</p><p>以上就是 Vue 常用的生命周期钩子函数，通过这些钩子函数，我们可以在不同的阶段执行相应的操作，从而实现更加灵活和高效的 Vue 应用程序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2基础</title>
      <link href="/2023/02/16/watch%E5%92%8Ccomputed/"/>
      <url>/2023/02/16/watch%E5%92%8Ccomputed/</url>
      
        <content type="html"><![CDATA[<h2 id="computed与watch"><a href="#computed与watch" class="headerlink" title="computed与watch"></a>computed与watch</h2><p>​通俗来讲，既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed， 重点在于 computed 的缓存功能 computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量 改变时，计算属性也会跟着改变； watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</p><p><strong>watch 属性监听</strong> 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用</p><p><strong>computed 计算属性</strong> 属性的结果会被<code>缓存</code>，当<code>computed</code>中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用 <code>computed</code>中的函数必须用<code>return</code>返回最终的结果 <code>computed</code>更高效，优先使用。<code>data 不改变，computed 不更新。</code></p><p><strong>使用场景</strong> <code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能 <code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p><h2 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h2><p>1.一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。 2.如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。 </p><h2 id="为什么v-for和v-if不建议用在一起"><a href="#为什么v-for和v-if不建议用在一起" class="headerlink" title="为什么v-for和v-if不建议用在一起"></a>为什么v-for和v-if不建议用在一起</h2><p>1.当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费（Vue2.x）<br> 2.这种场景建议使用 computed，先对数据进行过滤</p><p>注意：3.x 版本中 <code>v-if</code> 总是优先于 <code>v-for</code> 生效。由于语法上存在歧义，建议避免在同一元素上同时使用两者。比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p><h2 id="React-x2F-Vue-项目中-key-的作用"><a href="#React-x2F-Vue-项目中-key-的作用" class="headerlink" title="React&#x2F;Vue 项目中 key 的作用"></a>React&#x2F;Vue 项目中 key 的作用</h2><ul><li>key的作用是为了在diff算法执行时更快的找到对应的节点，<code>提高diff速度，更高效的更新虚拟DOM</code>;</li></ul><p>vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p><ul><li>为了在数据变化时强制更新组件，以避免<code>“就地复用”</code>带来的副作用。</li></ul><p>当 Vue.js 用 <code>v-for</code> 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</p><h2 id="vue组件的通信方式"><a href="#vue组件的通信方式" class="headerlink" title="vue组件的通信方式"></a>vue组件的通信方式</h2><ul><li><code>props</code>&#x2F;<code>$emit</code> 父子组件通信</li></ul><p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code> 获取父子组件实例 <code>parent、children</code> <code>Ref </code>获取实例的方式调用组件的属性或者方法 父-&gt;子孙 <code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p><ul><li><code>$emit</code>&#x2F;<code>$on</code> 自定义事件 兄弟组件通信</li></ul><p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</p><ul><li>vuex 跨级组件通信</li></ul><p>Vuex、<code>$attrs、$listeners</code> <code>Provide、inject</code></p><h2 id="nextTick的实现"><a href="#nextTick的实现" class="headerlink" title="nextTick的实现"></a>nextTick的实现</h2><ol><li><code>nextTick</code>是<code>Vue</code>提供的一个全局<code>API</code>,是在下次<code>DOM</code>更新循环结束之后执行延迟回调，在修改数据之后使用<code>$nextTick</code>，则可以在回调中获取更新后的<code>DOM</code>；</li><li>Vue在更新DOM时是异步执行的。只要侦听到数据变化，<code>Vue</code>将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个<code>watcher</code>被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和<code>DOM</code>操作是非常重要的。<code>nextTick</code>方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；</li><li>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；</li><li>我也有简单了解<code>nextTick</code>实现，它会在<code>callbacks</code>里面加入我们传入的函数，然后用<code>timerFunc</code>异步方式调用它们，首选的异步方式会是<code>Promise</code>。这让我明白了为什么可以在<code>nextTick</code>中看到<code>dom</code>操作结果。</li></ol><h2 id="nextTick的实现原理是什么？"><a href="#nextTick的实现原理是什么？" class="headerlink" title="nextTick的实现原理是什么？"></a>nextTick的实现原理是什么？</h2><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。 nextTick主要使用了宏任务和微任务。 根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p><h2 id="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"><a href="#使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽" class="headerlink" title="使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽"></a>使用过插槽么？用的是具名插槽还是匿名插槽或作用域插槽</h2><p>vue中的插槽是一个非常好用的东西slot说白了就是一个占位的 在vue当中插槽包含三种一种是默认插槽（匿名）一种是具名插槽还有一种就是作用域插槽 匿名插槽就是没有名字的只要默认的都填到这里具名插槽指的是具有名字的 </p><h2 id="keep-alive的实现"><a href="#keep-alive的实现" class="headerlink" title="keep-alive的实现"></a>keep-alive的实现</h2><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染</p><p>场景：tabs标签页 后台导航，vue性能优化</p><p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin<br> 多个组件有相同的逻辑，抽离出来<br> mixin并不是完美的解决方案，会有一些问题<br> vue3提出的Composition API旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】<br> 场景：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合<br> 劣势：1.变量来源不明确，不利于阅读<br> 2.多mixin可能会造成命名冲突 3.mixin和组件可能出现多对多的关系，使得项目复杂度变高</p><h2 id="Vuex的理解及使用场景"><a href="#Vuex的理解及使用场景" class="headerlink" title="Vuex的理解及使用场景"></a>Vuex的理解及使用场景</h2><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p><ol><li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，</li></ol><p>若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</p><ol><li>State：定义了应用的状态数据</li><li>Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），</li></ol><p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p>]]></content>
      
      
      <categories>
          
          <category> vue2基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> watch和computed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue生命周期的理解</title>
      <link href="/2023/02/16/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/02/16/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>每个<code>Vue</code>实例在创建时都会经过一系列的初始化过程，<code>vue</code>的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件</p><ul><li><code>create阶段</code>：vue实例被创建<br> <code>beforeCreate</code>: 创建前，此时data和methods中的数据都还没有初始化<br> <code>created</code>： 创建完毕，data中有值，未挂载</li><li><code>mount阶段</code>： vue实例被挂载到真实DOM节点<br> <code>beforeMount</code>：可以发起服务端请求，去数据<br> <code>mounted</code>: 此时可以操作DOM</li><li><code>update阶段</code>：当vue实例里面的data数据变化时，触发组件的重新渲染<br> <code>beforeUpdate</code> :更新前<br> <code>updated</code>：更新后</li><li><code>destroy阶段</code>：vue实例被销毁<br> <code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法<br> <code>destroyed</code>:销毁后</li></ul><p> 组件生命周期</p><p>生命周期（父子组件） 父组件beforeCreate –&gt; 父组件created –&gt; 父组件beforeMount –&gt; 子组件beforeCreate –&gt; 子组件created –&gt; 子组件beforeMount –&gt; 子组件 mounted –&gt; 父组件mounted –&gt;父组件beforeUpdate –&gt;子组件beforeDestroy–&gt; 子组件destroyed –&gt; 父组件updated</p><p><strong>加载渲染过程</strong> 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><p><strong>挂载阶段</strong> 父created-&gt;子created-&gt;子mounted-&gt;父mounted</p><p><strong>父组件更新阶段</strong> 父beforeUpdate-&gt;父updated</p><p><strong>子组件更新阶段</strong> 父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><p><strong>销毁阶段</strong> 父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>]]></content>
      
      
      <categories>
          
          <category> vue生命周期 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue底层实现原理</title>
      <link href="/2023/02/16/vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2023/02/16/vue%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue底层实现原理"><a href="#Vue底层实现原理" class="headerlink" title="Vue底层实现原理"></a>Vue底层实现原理</h3><p>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调<br> Vue是一个典型的MVVM框架，模型（Model）只是普通的javascript对象，修改它则试图（View）会自动更新。这种设计让状态管理变得非常简单而直观</p><p><strong>Observer（数据监听器）</strong> : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher</p><p><strong>Watcher（订阅者）</strong> : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：</p><ol><li>在自身实例化时往属性订阅器(dep)里面添加自己</li><li>自身必须有一个update()方法</li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</li></ol><p><strong>Compile（指令解析器）</strong> : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和localStorage</title>
      <link href="/2023/02/16/Cookie%E5%92%8ClocalStorage/"/>
      <url>/2023/02/16/Cookie%E5%92%8ClocalStorage/</url>
      
        <content type="html"><![CDATA[<ol><li><ul><li><h2 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h2><p><strong>相同点</strong>：</p><ul><li>存储在客户端</li></ul><p><strong>不同点</strong>：</p></li></ul></li></ol><ul><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie和localStorage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http和https</title>
      <link href="/2023/02/16/http/"/>
      <url>/2023/02/16/http/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><h2 id="http-和-https-的基本概念"><a href="#http-和-https-的基本概念" class="headerlink" title="http 和 https 的基本概念"></a>http 和 https 的基本概念</h2><p>http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。</p><p> https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><h2 id="http-和-https-的区别及优缺点？"><a href="#http-和-https-的区别及优缺点？" class="headerlink" title="http 和 https 的区别及优缺点？"></a>http 和 https 的区别及优缺点？</h2><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 协议的<code>默认端口</code>为 80，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>Https 协议需要 ca 证书，费用较高，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h2 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h2><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack&#x3D;j+1），<code>同时也发送一个自己的SYN包</code>（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><ol><li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，<code>客户端进入FIN-WAIT-1（终止等待1）状态</code>。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li><code>服务器收到连接释放报文，发出确认报文</code>，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，<code>服务端就进入了CLOSE-WAIT（关闭等待）状态</code>。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，<code>客户端就进入FIN-WAIT-2（终止等待2）状态</code>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</li><li><code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，<code>服务器就进入了LAST-ACK（最后确认）状态</code>，等待客户端的确认。</li><li><code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，<code>客户端就进入了TIME-WAIT（时间等待）状态</code>。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，<code>当客户端撤销相应的TCB后，才进入CLOSED状态</code>。</li><li>服务器只要收到了客户端发出的确认，<code>立即进入CLOSED状态</code>。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<code>服务器结束TCP连接的时间要比客户端早一些</code>。</li></ol><h2 id="TCP-x2F-IP-x2F-如何保证数据包传输的有序可靠"><a href="#TCP-x2F-IP-x2F-如何保证数据包传输的有序可靠" class="headerlink" title="TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠"></a>TCP&#x2F;IP &#x2F; 如何保证数据包传输的有序可靠</h2><p>对字节流分段并进行编号然后<code>通过 ACK 回复</code>和<code>超时重发</code>这两个机制来保证。</p><ol><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</li><li>并为每个已发送的数据包启动一个超时定时器；</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol><li>TCP是面向<code>链接</code>的，而UDP是面向无连接的。</li><li>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</li></ol><h2 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h2><ol><li><p>跨域的原理</p><p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br> <strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br> <strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p></li><li><p>解决方案</p><p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p><ul><li><p><strong>JSONP</strong>：<br> ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p><p>步骤：</p><ol><li>去创建一个script标签</li><li>script的src属性设置接口地址</li><li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li><li>通过定义函数名去接受返回的数据</li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//动态创建 script</span><br><span class="line">var script = document.createElement(&#x27;script&#x27;);</span><br><span class="line"></span><br><span class="line">// 设置回调函数</span><br><span class="line">function getData(data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//设置 script 的 src 属性，并设置请求地址</span><br><span class="line">script.src = &#x27;http://localhost:3000/?callback=getData&#x27;;</span><br><span class="line"></span><br><span class="line">// 让 script 生效</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure><ul><li><p><strong>JSONP 的缺点</strong>:<br> JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p><p><strong>document.domain</strong> 基础域名相同 子域名不同</p><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p><p><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p><p><strong>proxy代理</strong> 目前常用方式,通过服务器设置代理</p><p><strong>window.postMessage()</strong> 利用h5新特性window.postMessage()</p></li></ul><h2 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h2></li></ul></li></ol><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。 </p><h4 id="粘包出现原因"><a href="#粘包出现原因" class="headerlink" title="粘包出现原因"></a><strong>粘包出现原因</strong></h4><p>简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p><p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p><p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p><ol><li><p>对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p></li><li><p>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p></li><li><p>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p><ul><li>以上提到的三种措施，都有其不足之处。</li><li>第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> js网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http和https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本命年生日</title>
      <link href="/2023/02/15/%E6%9C%AC%E5%91%BD%E5%B9%B4%E7%94%9F%E6%97%A5/"/>
      <url>/2023/02/15/%E6%9C%AC%E5%91%BD%E5%B9%B4%E7%94%9F%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="生日快乐"><a href="#生日快乐" class="headerlink" title="生日快乐"></a>生日快乐</h1><ul><li>今天是我人生中第二个本命年生日，这十二年自己经历了许许多多的挫折，受了数不清的委屈，走了不少弯路</li><li>但是这十二年我成长了很多，我懂得了如何提升自己学习能力，从一个不爱学习的小家伙成长为了一个爱学习的大家伙，从不自律，作息不规律的赖床虫改变成了一个早起不赖床的早起鸟</li><li>我不知道后面这十二年我会成长成什么样子的人，但是我会努力再努力，不会怕苦怕累，学会永久性独立思考，善于思考，懂于分析问题的成熟大叔</li><li>这个博客不知道我会维护多久，倘若下一个十二年还在，不知道那时候的我会不会觉得今天我说的话很幼稚呢，哈哈哈</li><li>好了，祝自己接下来找工作一切顺利吧，万事胜意</li><li><img src="https://s1.ax1x.com/2023/02/15/pSTbEtJ.jpg" alt="pSTbEtJ.jpg"></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 生日 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO/AO/VO</title>
      <link href="/2023/02/14/GO-AO-VO/"/>
      <url>/2023/02/14/GO-AO-VO/</url>
      
        <content type="html"><![CDATA[<h1 id="对GO-x2F-AO-x2F-VO的理解"><a href="#对GO-x2F-AO-x2F-VO的理解" class="headerlink" title="对GO&#x2F;AO&#x2F;VO的理解"></a>对GO&#x2F;AO&#x2F;VO的理解</h1><h2 id="GO"><a href="#GO" class="headerlink" title="GO"></a>GO</h2><ul><li>Global Object JS代码在执⾏前会现在堆内存中创建⼀个全局对象(GO) </li><li>⽤于存放⼀些定义好的变量⽅法等包含Date Array String Number setTimeout等 </li><li>同时有⼀个window属性指向⾃⼰</li><li>同时在语法分析转成AST的过程中也会将⼀些变量 函数 存放在GO中 只是变量的初始值为 undefifined</li></ul><h2 id="AO"><a href="#AO" class="headerlink" title="AO"></a>AO</h2><ul><li>函数在执⾏前会先在堆内存中创建⼀个AO(Activation Object)对象 ⾥⾯存放这arguments 对应函数的形参 以及在函数中定义的变量 初始值为undefifined</li></ul><h2 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h2><ul><li>Variable Object 在执⾏函数时 会在执⾏上下⽂栈(ECS)中进⼊⼀个函数执⾏上下⽂(FEC)其中有三个核⼼ 核⼼之⼀是VO 指向的是该函数在内存中解析时创建的AO ⽽在全局执⾏上下⽂中指向的是GO</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO/AO/VO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2023/02/14/%E5%87%BD%E6%95%B0/"/>
      <url>/2023/02/14/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数-篇章"><a href="#函数-篇章" class="headerlink" title="函数 篇章"></a>函数 篇章</h1><h2 id="apply、call、bind函数的⽤法和区别？"><a href="#apply、call、bind函数的⽤法和区别？" class="headerlink" title="apply、call、bind函数的⽤法和区别？"></a>apply、call、bind函数的⽤法和区别？</h2><h4 id="⽤法："><a href="#⽤法：" class="headerlink" title="⽤法："></a>⽤法：</h4><ul><li><p>apply </p><p>第⼀个参数: 绑定this </p><p>第⼆个参数: 传⼊额外的实参, 以数组的形式</p></li><li><p>call </p><p>第⼀个参数: 绑定this </p><p>参数列表: 后续的参数以多参数的形式传递, 会作为实参 </p><p>bind(不希望obj对象身上有函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bar = foo.bind(obj)</span><br><span class="line">bar() // this -&gt; obj</span><br></pre></td></tr></table></figure></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>call、apply和bind都可以改变函数的this指向 </li><li>call、apply和bind第⼀个参数的是this要指向的对象 </li><li>call、apply和bind都可以后续为函数传参，apply是将参数并成⼀个数组，call和bind是将参数依次列出</li><li>call、apply都是直接调⽤，bind⽣成的this指向改变函数需要⼿动调⽤。</li></ul><h3 id="什么是纯函数？如何编写纯函数？"><a href="#什么是纯函数？如何编写纯函数？" class="headerlink" title="什么是纯函数？如何编写纯函数？"></a>什么是纯函数？如何编写纯函数？</h3><h4 id="纯函数：纯函数⼀般具有以下的特点："><a href="#纯函数：纯函数⼀般具有以下的特点：" class="headerlink" title="纯函数：纯函数⼀般具有以下的特点："></a>纯函数：纯函数⼀般具有以下的特点：</h4><ul><li><p>确定的输⼊⼀定会有确定的输出（外部环境的任何变化不会影响函数内部的操作产⽣的结果） </p></li><li><p>纯函数的执⾏不会产⽣副作⽤。（函数内部的操作也不会对函数外部产⽣任何影响） </p></li><li><p>纯函数在react和redux中应⽤⽐较多。 </p><ul><li><p>编写纯函数：</p></li><li><pre><code>//⼀般的数学⽅法可以写成纯函数,例如相加function sum(...args) &#123;var result = args.reduce((perValue, item) =&gt; &#123;return preValue + item &#125;, 0)return result&#125;</code></pre></li></ul></li></ul><h3 id="什么是函数柯⾥化？柯⾥化有什么作⽤？"><a href="#什么是函数柯⾥化？柯⾥化有什么作⽤？" class="headerlink" title="什么是函数柯⾥化？柯⾥化有什么作⽤？"></a>什么是函数柯⾥化？柯⾥化有什么作⽤？</h3><h4 id="函数的柯⾥化："><a href="#函数的柯⾥化：" class="headerlink" title="函数的柯⾥化："></a>函数的柯⾥化：</h4><ul><li>将传⼊多个参数的函数转变成传⼊单个参数并且返回⼀个函数⽤于接收剩余的参数的函数 </li><li>每⼀层函数都接收⼀个参数并对参数进⾏处理。</li></ul><h4 id="柯⾥化的作⽤："><a href="#柯⾥化的作⽤：" class="headerlink" title="柯⾥化的作⽤："></a>柯⾥化的作⽤：</h4><ul><li>单⼀职责：每⼀个函数只⽤处理传⼊的单个参数，每个函数的职责单⼀⽽且确定 </li><li>参数复⽤：可以拿到每⼀层函数执⾏的返回值作为⼀个新的函数，复⽤已经传⼊过的参数。</li></ul><h3 id="组合函数以及组合函数的作⽤？"><a href="#组合函数以及组合函数的作⽤？" class="headerlink" title="组合函数以及组合函数的作⽤？"></a>组合函数以及组合函数的作⽤？</h3><h4 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h4><ul><li>组合函数是将多个函数组合到⼀起，进⾏依次调⽤的函数使⽤模式。</li></ul><h4 id="组合函数的作⽤："><a href="#组合函数的作⽤：" class="headerlink" title="组合函数的作⽤："></a>组合函数的作⽤：</h4><ul><li>减少重复代码的编写，提⾼代码的复⽤性，便于开发。</li><li>可以对任意个函数进⾏组合，返回新的具有多个被组合函数功能的新函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2023/02/14/%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/14/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="常⽤的数组操作⽅法有哪些？"><a href="#常⽤的数组操作⽅法有哪些？" class="headerlink" title="常⽤的数组操作⽅法有哪些？"></a>常⽤的数组操作⽅法有哪些？</h2><h3 id="Array-shift"><a href="#Array-shift" class="headerlink" title="Array.shift()"></a>Array.shift()</h3><ul><li>删除并返回第⼀个元素作⽤：从数组中删除第⼀个元素（即下标为0的元素），并返回该元素。 注意：1）删除元素之后，数组的⻓度-1。</li></ul><h3 id="Array-pop"><a href="#Array-pop" class="headerlink" title="Array.pop()"></a>Array.pop()</h3><ul><li>删除并返回最后⼀个元素 作⽤：从数组中删除最后⼀个元素（即下标为length-1的元素），并返回该元素。 注意：1）删除元素之后，数组的⻓度-1。</li></ul><h3 id="Array-push-param1-param2-…paramN"><a href="#Array-push-param1-param2-…paramN" class="headerlink" title="Array.push(param1[,param2,…paramN])"></a>Array.push(param1[,param2,…paramN])</h3><ul><li>尾部添加元素 作⽤：在数组的尾部添加⼀个元素，并返回新数组的⻓度。 注意：1）它是直接修改该数组，⽽不是重新创建⼀个数组。</li></ul><h3 id="Array-unshift-newElement1-newElement2-…newElementN"><a href="#Array-unshift-newElement1-newElement2-…newElementN" class="headerlink" title="Array.unshift(newElement1[,newElement2,…newElementN])"></a>Array.unshift(newElement1[,newElement2,…newElementN])</h3><ul><li>头部添加元素 作⽤：在数组的头部添加⼀个或多个元素，并返回新数组的⻓度。 注意：1）它是直接修改该数组，⽽不是重新创建⼀个数组</li></ul><h3 id="Array-join-separator"><a href="#Array-join-separator" class="headerlink" title="Array.join([separator])"></a>Array.join([separator])</h3><ul><li>转换成字符串 作⽤：把数组的所有元素放⼊到⼀个字符串中。 注意：1）参数separator表示字符串中元素的分隔符，可以为空，默认为半⻆逗号。</li></ul><h3 id="Array-reverse"><a href="#Array-reverse" class="headerlink" title="Array.reverse()"></a>Array.reverse()</h3><ul><li><p>反转数组 作⽤：把数组的所有元素顺序反转。 注意：1）该⽅法会直接修改数组，⽽不会创建新的 </p><p>数组</p></li></ul><h2 id="数组如何进⾏降维（扁平化）"><a href="#数组如何进⾏降维（扁平化）" class="headerlink" title="数组如何进⾏降维（扁平化）"></a>数组如何进⾏降维（扁平化）</h2><ul><li><p>利⽤Array.some⽅法判断数组中是否还存在数组，es6展开运算符连接数组 </p></li><li><pre><code>let arr = [1,2,[3,4]]while (arr.some(item =&gt; Array.isArray(item))) &#123;arr = [].concat(...arr);&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 使⽤数组的concat⽅法 </span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  let arr = [1,2,[3,4]]</span><br><span class="line">  let result = []</span><br><span class="line">  result = Array.prototype.concat.apply([], arr)</span><br></pre></td></tr></table></figure></code></pre></li><li><p>es6中的flat函数也可以实现数组的扁平化 </p></li><li><pre><code>let arr = [1,2,[&#39;a&#39;,&#39;b&#39;,[&#39;中&#39;,&#39;⽂&#39;,[1,2,3,[11,21,31]]]],3];let result = arr.flat( Infinity )<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 数组去重，能⽤⼏种⽅法实现？ </span><br><span class="line"></span><br><span class="line">+ 利⽤ES6 Set去重（ES6中最常⽤） </span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  function unique (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  //[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">+ 利⽤for嵌套for，然后splice去重（ES5中最常⽤） </span><br><span class="line"></span><br><span class="line">+ ````</span><br><span class="line">  function unique(arr)&#123; </span><br><span class="line">  for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">  for(var j=i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">  if(arr[i]==arr[j])&#123; //第⼀个等同于第⼆个，splice⽅法删除第⼆个</span><br><span class="line">  arr.splice(j,1);</span><br><span class="line">  j--;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  //[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;] //NaN和&#123;&#125;没</span><br><span class="line">  有去重，两个null直接消失了</span><br></pre></td></tr></table></figure></code></pre></li><li><p>利⽤indexOf去重 </p></li><li><pre><code>function unique(arr) &#123;if (!Array.isArray(arr)) &#123;console.log(&#39;type error!&#39;)return &#125;var array = [];for (var i = 0; i &lt; arr.length; i++) &#123;if (array .indexOf(arr[i]) === -1) &#123;array .push(arr[i]) &#125; &#125;return array;&#125;var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined,null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;,&#123;…&#125;] //NaN、&#123;&#125;没有去重<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 利⽤sort去重 </span><br><span class="line"></span><br><span class="line">+ ````</span><br><span class="line">  function unique(arr) &#123;</span><br><span class="line">  if (!Array.isArray(arr)) &#123;</span><br><span class="line">  console.log(&#x27;type error!&#x27;)</span><br><span class="line">  return;</span><br><span class="line">   &#125;</span><br><span class="line">  arr = arr.sort()</span><br><span class="line">  var arrry= [arr[0]];</span><br><span class="line">  for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (arr[i] !== arr[i-1]) &#123;</span><br><span class="line">  arrry.push(arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  return arrry;</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  // [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;,</span><br><span class="line">  undefined] // NaN、&#123;&#125;没有去重</span><br></pre></td></tr></table></figure></code></pre></li><li><p>利⽤includes </p></li><li><pre><code>function unique(arr) &#123;if (!Array.isArray(arr)) &#123;console.log(&#39;type error!&#39;)return &#125;var array =[];for(var i = 0; i &lt; arr.length; i++) &#123;if( !array.includes( arr[i]) ) &#123;//includes 检测数组是否有某个值array.push(arr[i]); &#125; &#125;return array&#125;var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined,null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;];console.log(unique(arr))//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]// &#123;&#125; 没有去重<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 利⽤fifilter</span><br><span class="line"></span><br><span class="line">+ ```</span><br><span class="line">  function unique(arr) &#123;</span><br><span class="line">  return arr.filter(function(item, index, arr) &#123;</span><br><span class="line">  //当前元素，在原始数组中的第⼀个索引==当前索引值，否则返回当前元素</span><br><span class="line">  return arr.indexOf(item, 0) === index;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  var arr = [1,1,&#x27;true&#x27;,&#x27;true&#x27;,true,true,15,15,false,false, undefined,undefined,</span><br><span class="line">  null,null, NaN, NaN,&#x27;NaN&#x27;, 0, 0, &#x27;a&#x27;, &#x27;a&#x27;,&#123;&#125;,&#123;&#125;];</span><br><span class="line">  console.log(unique(arr))</span><br><span class="line">  //[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span><br></pre></td></tr></table></figure></code></pre></li><li><p>利⽤递归去重 </p></li><li><pre><code>function unique(arr)&#123;return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : [...prev,cur],[]);&#125;var arr = [1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined,null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;];console.log(unique(arr));// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</code></pre></li></ul><h2 id="数组中的forEach和map的区别？"><a href="#数组中的forEach和map的区别？" class="headerlink" title="数组中的forEach和map的区别？"></a>数组中的forEach和map的区别？</h2><p>forEach() 和 map() 两个⽅法都是ECMA5中Array引进的新⽅法，都是⽤来遍历数组中的每⼀项。 </p><h4 id="它们之间的区别："><a href="#它们之间的区别：" class="headerlink" title="它们之间的区别："></a>它们之间的区别：</h4><ul><li>map速度⽐forEach快 </li><li>map会返回⼀个新数组，不对原数组产⽣影响,foreach不会产⽣新数组，forEach返回undefifined </li><li>map因为返回数组所以可以链式操作，forEach不能 </li><li>map⾥可以⽤return（return的是什么，相当于把数组中的这⼀项变为什么（并不影响原来的数 组，只是相当于把原数组克隆⼀份，把克隆的这⼀份的数组中的对应项改变了） 。 </li><li>forEach⾥⽤return不起作⽤，forEach不能⽤break，会直接报错。</li></ul><h2 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别?"></a>for in和for of的区别?</h2><p>在JavaScript中遍历数组通常是使⽤for…i循环，在ES5具有遍历数组功能的还有forEach、map、fifilter、 </p><p>some、every、reduce、reduceRight等。for…in和for…of是两种增强型循环，for…in是ES5标准，在 </p><p>ES6中新增了for…of的循环⽅式。</p><ul><li>for…in ：遍历以任意顺序迭代⼀个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性 </li><li>for…of：遍历在可迭代对象，包括 Array ， Map ， Set ， String ， TypedArray ，arguments 对象等等</li><li>它们的区别 :<ul><li>for…in可以遍历对象和数组，for…of不能遍历对象 </li><li>for…in 循环不仅遍历对象的键名，还会遍历⼿动添加的其它键，甚⾄包括原型链上的键 </li><li>for…in遍历的索引为字符串类型</li><li>for..of适⽤遍历数&#x2F;数组对象&#x2F;字符串&#x2F;map&#x2F;set等拥有迭代器对象的集合，但是不能遍历对象 </li><li>for…of与forEach()不同的是，它可以正确响应break、continue和return语句具有迭代器对象才可以使⽤for…of</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2023/02/14/%E9%97%AD%E5%8C%85/"/>
      <url>/2023/02/14/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="你是如何理解闭包的-闭包到底是什么"><a href="#你是如何理解闭包的-闭包到底是什么" class="headerlink" title="你是如何理解闭包的,闭包到底是什么?"></a>你是如何理解闭包的,闭包到底是什么?</h1><ul><li><p>什么是闭包？ </p><p>⼀个普通的函数function，如果它可以访问外层作⽤域的⾃由变量，那么这个函数和周围环境就是⼀个闭包。 </p><p>从狭义的⻆度来说：JavaScript中⼀个函数，如果访问了外层作⽤域的变量，那么它是⼀个闭包</p></li><li><p>应⽤场景 </p><p>防抖 、节流 、⽴即执⾏函数 、组合函数等等 </p><h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><ul><li><p>函数执行时形成的私有上下文EC(FN)，正常情况下，代码执行完会出栈后释放;但是特殊情况下，如果当前私有上下文中的某个东西被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不销毁的上下文。 函数执行函数执行过程中，会形成一个全新的私有上下文，可能会被释放，可能不会被释放，不论释放与否，他的作用是：</p></li><li><p>保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系</p></li><li><p>保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</p><p>我们把函数执行形成私有上下文，来保护和保存私有变量机制称为<code>闭包</code>。</p></li></ul><h4 id="稍全面的回答："><a href="#稍全面的回答：" class="headerlink" title="稍全面的回答："></a><strong>稍全面的回答</strong>：</h4><p> 在js中变量的作用域属于函数作用域, 在函数执行完后,作用域就会被清理,内存也会随之被回收,但是由于闭包函数是建立在函数内部的子函数, 由于其可访问上级作用域,即使上级函数执行完, 作用域也不会随之销毁, 这时的子函数(也就是闭包),便拥有了访问上级作用域中变量的权限,即使上级函数执行完后作用域内的值也不会被销毁。</p><h4 id="闭包的特性："><a href="#闭包的特性：" class="headerlink" title="闭包的特性："></a><strong>闭包的特性</strong>：</h4><ul><li><p>1、内部函数可以访问定义他们外部函数的参数和变量。(作用域链的向上查找，把外围的作用域中的变量值存储在内存中而不是在函数调用完毕后销毁)设计私有的方法和变量，避免全局变量的污染。</p><p>1.1.闭包是密闭的容器，，类似于set、map容器，存储数据的</p><p>1.2.闭包是一个对象，存放数据的格式为 key-value 形式</p></li><li><p>2、函数嵌套函数</p></li><li><p>3、本质是将函数内部和外部连接起来。优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除</p></li></ul><ul><li><p><strong>闭包形成的条件</strong>：</p><ol><li>函数的嵌套</li><li>内部函数引用外部函数的局部变量，延长外部函数的变量生命周期</li></ol></li><li><p><strong>闭包的用途</strong>：</p><ol><li>模仿块级作用域</li><li>保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)</li><li>封装私有化变量</li><li>创建模块</li></ol></li></ul></li><li><ol><li><strong>闭包应用场景</strong></li></ol><p>闭包的两个场景，闭包的两大作用：<code>保存/保护</code>。 在开发中, 其实我们随处可见闭包的身影, 大部分前端JavaScript 代码都是“事件驱动”的,即一个事件绑定的回调方法; 发送ajax请求成功|失败的回调;setTimeout的延时回调;或者一个函数内部返回另一个匿名函数,这些都是闭包的应用。</p></li><li><p><strong>闭包的优点</strong>：</p><p>延长局部变量的生命周期</p></li><li><p><strong>闭包缺点</strong>：</p><p>会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域</title>
      <link href="/2023/02/14/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2023/02/14/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="作⽤域和作⽤域链的理解"><a href="#作⽤域和作⽤域链的理解" class="headerlink" title="作⽤域和作⽤域链的理解"></a>作⽤域和作⽤域链的理解</h1><h2 id="作⽤域"><a href="#作⽤域" class="headerlink" title="作⽤域"></a>作⽤域</h2><ul><li>在ES5中，全局是⼀个作⽤域，函数也会产⽣作⽤域。 </li><li>在ES6中，代码块、let、const等都会有属于⾃⼰的作⽤域。</li></ul><h2 id="作⽤域链"><a href="#作⽤域链" class="headerlink" title="作⽤域链"></a>作⽤域链</h2><ul><li>当进⼊到⼀个执⾏上下⽂时，执⾏上下⽂会关联⼀个作⽤域链。 </li><li>通常作⽤域链在解析时就被确定，作⽤域链与函数的定义位置有关，与它的调⽤位置⽆关</li></ul><h2 id="什么是变量提升、函数提升？"><a href="#什么是变量提升、函数提升？" class="headerlink" title="什么是变量提升、函数提升？"></a>什么是变量提升、函数提升？</h2><h3 id="变量提升："><a href="#变量提升：" class="headerlink" title="变量提升："></a>变量提升：</h3><ul><li><p>简单说就是在js代码执⾏前引擎会先进⾏预编译，预编译期间会将变量声明与函数声明提升⾄其对应作⽤域的最顶端，函数内声明的变量只会提升⾄该函数作⽤域最顶层。 </p></li><li><p>当函数内部定义的⼀个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端。</p></li><li><p>举个例⼦，如： </p><ul><li><pre><code>console.log(a); // undefinedvar a = 3; // 会将var a 的声明提升⾄最顶端</code></pre></li><li></li></ul></li></ul><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><ul><li>函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升。 </li><li>函数提升的优先级⼤于变量提升的优先级，即函数提升在变量提升之上。</li></ul>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this绑定</title>
      <link href="/2023/02/14/this%E7%BB%91%E5%AE%9A/"/>
      <url>/2023/02/14/this%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="this绑定"><a href="#this绑定" class="headerlink" title="this绑定"></a>this绑定</h1><h2 id="this的绑定规则有⼏种？"><a href="#this的绑定规则有⼏种？" class="headerlink" title="this的绑定规则有⼏种？"></a>this的绑定规则有⼏种？</h2><ul><li>默认绑定：独⽴函数调⽤，函数没有被绑定到某个对象上进⾏调⽤ </li><li>隐式绑定：通过某个对象发起的函数调⽤，在调⽤对象内部有⼀个对函数的引⽤。 </li><li>显式绑定：明确this指向的对象，第⼀个参数相同并要求传⼊⼀个对象。 <ul><li>apply&#x2F;call </li><li>bind</li></ul></li><li>new绑定： <ul><li>创建⼀个全新对象 </li><li>新对象被执⾏prototype链接 </li><li>新对象绑定到函数调⽤的this </li><li>如果函数没有返回其他对象，表达式会返回这个对象</li></ul></li></ul><h2 id="this的⾯试题解析"><a href="#this的⾯试题解析" class="headerlink" title="this的⾯试题解析"></a>this的⾯试题解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.foo1 = function () &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line">this.foo2 = () =&gt; console.log(this.name);</span><br><span class="line">this.foo3 = function () &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line">this.foo4 = function () &#123;</span><br><span class="line">return () =&gt; &#123;</span><br><span class="line">console.log(this.name);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;person1&quot;);</span><br><span class="line">var person2 = new Person(&quot;person2&quot;);</span><br><span class="line">// person1.foo1() // person1 隐式调⽤</span><br><span class="line">// person1.foo1.call(person2) // person2 显示调⽤ this指向person2所在的对象</span><br><span class="line">// person1.foo2(); // person1 箭头函数 向上层作⽤查找 上层作⽤域中的this为person1指向</span><br><span class="line">的对象</span><br><span class="line">// person1.foo2.call(person2); // person1 箭头函数 显示绑定没⽤</span><br><span class="line">// person1.foo3()() // window 相当于将返回的函数赋值给⼀个变量 指向该变量 是独⽴函数调⽤</span><br><span class="line">// person1.foo3.call(person2)() // window 默认调⽤</span><br><span class="line">// person1.foo3().call(person2) // person2 将函数的this显示绑定到person2所在的对象</span><br><span class="line">// person1.foo4()() // person1 箭头函数 向上层作⽤域中查找this foo4中的this隐式绑定为</span><br><span class="line">person1</span><br><span class="line">// person1.foo4.call(person2)() // person2 箭头函数 向上层作⽤域中查找this foo4中</span><br><span class="line">的this显示绑定为person2</span><br><span class="line">// person1.foo4().call(person2) // person1 箭头函数显示绑定没⽤和person1.foo4()相同</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>a标签下载文件</title>
      <link href="/2023/02/14/a%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2023/02/14/a%E6%A0%87%E7%AD%BE%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="点击-a-标签下载⽂件如何做？"><a href="#点击-a-标签下载⽂件如何做？" class="headerlink" title="点击 a 标签下载⽂件如何做？"></a>点击 a 标签下载⽂件如何做？</h1><h1 id="有两种⽅式"><a href="#有两种⽅式" class="headerlink" title="有两种⽅式:"></a>有两种⽅式:</h1><p>a.download 当指定 a 标签的 download 属性时，点击该链接会直接保存为⽂件，⽂件名为 </p><p>download 属性 </p><p>通过对 a 标签指定的 URL 在服务器设置响应头 Content-Disposition: attachment; </p><p>filename&#x3D;”filename.jpg” 可直接下载</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> a标签下载文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Element与Node区别</title>
      <link href="/2023/02/14/Element%E4%B8%8ENode%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/14/Element%E4%B8%8ENode%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM-中-Element-与-Node-有何区别"><a href="#DOM-中-Element-与-Node-有何区别" class="headerlink" title="DOM 中 Element 与 Node 有何区别"></a>DOM 中 Element 与 Node 有何区别</h1><p>Element 继承于 Node，具有 Node 的⽅法，同时⼜拓展了很多⾃⼰的特有⽅法。 </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Element与Node区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不可复制</title>
      <link href="/2023/02/14/%E4%B8%8D%E5%8F%AF%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/02/14/%E4%B8%8D%E5%8F%AF%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现⻚⾯⽂本不可复制"><a href="#如何实现⻚⾯⽂本不可复制" class="headerlink" title="如何实现⻚⾯⽂本不可复制"></a>如何实现⻚⾯⽂本不可复制</h1><p>有 CSS 和 JS 两种⽅法，以下任选其⼀或结合使⽤ </p><h3 id="使⽤-CSS-如下："><a href="#使⽤-CSS-如下：" class="headerlink" title="使⽤ CSS 如下："></a>使⽤ CSS 如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user-select: none;</span><br></pre></td></tr></table></figure><p>或使⽤ JS 如下，监听 selectstart 事件，禁⽌选中。 </p><p>当⽤户选中⼀⽚区域时，将触发 selectstart 事件，Selection API 将会选中⼀⽚区域。禁⽌选中区域 </p><p>即可实现⻚⾯⽂本不可复制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.body.onselectstart = (e) =&gt; &#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;;</span><br><span class="line">document.body.oncopy = (e) =&gt; &#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 不可复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prefetch和preload应用场景</title>
      <link href="/2023/02/14/prefetch%E5%92%8Cpreload%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/02/14/prefetch%E5%92%8Cpreload%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="preload和prefetch的应⽤场景？"><a href="#preload和prefetch的应⽤场景？" class="headerlink" title="preload和prefetch的应⽤场景？"></a>preload和prefetch的应⽤场景？</h1><h2 id="1-webpack优化之preload和prefetch："><a href="#1-webpack优化之preload和prefetch：" class="headerlink" title="1.webpack优化之preload和prefetch："></a>1.webpack优化之preload和prefetch：</h2><p>单⻚⾯应⽤由于⻚⾯过多，可能会导致代码体积过⼤，从⽽使得⾸⻚打开速度过慢。所以切分代码，优化⾸屏打开速度尤为重要。 </p><p>但是所有的技术⼿段都不是完美的。当我们切割代码后，⾸屏的js⽂件体积减少了好多。但是也有⼀个突出的问题： </p><p>那就是当跳转其他⻚⾯的时候，需要下载相应⻚⾯的js⽂件，这就导致体验极其不好，每⼀次点击访问 </p><p>新⻚⾯都要等待js⽂件下载，然后再去请求接⼝获取数据。频繁出现loading动画的体验真的不好 </p><p>所以如果我们在进⼊⾸⻚后，在浏览器的空闲时间提前下好⽤户可能会点击⻚⾯的js⽂件，这样⾸屏的js </p><p>⽂件⼤⼩得到了控制，⽽且再点击新⻚⾯的时候，相关的js⽂件已经下载好了，就不再会出现loading动画</p><h2 id="2-动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间"><a href="#2-动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间" class="headerlink" title="2.动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间"></a>2.动态引⼊js⽂件，实现code-splitting，减少⾸屏打开时间</h2><p>按引⼊情况加载，只需添加注释即可 </p><ul><li>代码分割注释：&#x2F;webpackChunkName: ‘mp-supports’&#x2F; </li><li>prefetch注释：&#x2F;* webpackPrefetch: true *&#x2F;</li></ul><p>更多的，可以查看 webpack 注释⿊魔法：<a href="https://webpack.js.org/api/module-methods/#magic-comments">https://webpack.js.org/api/module-methods/#magic-comments</a></p><p>以下便是使用案列:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123; default: lodash &#125; = await import(/* webpackChunkName: &quot;lodash&quot; */ /*</span><br><span class="line">webpackPrefetch: true */ &#x27;lodash&#x27;);</span><br><span class="line">// Multiple possible targets</span><br><span class="line">import(</span><br><span class="line">/* webpackInclude: /\.json$/ */</span><br><span class="line">/* webpackExclude: /\.noimport\.json$/ */</span><br><span class="line">/* webpackChunkName: &quot;my-chunk-name&quot; */</span><br><span class="line">/* webpackMode: &quot;lazy&quot; */</span><br><span class="line">/* webpackPrefetch: true */</span><br><span class="line">/* webpackPreload: true */</span><br><span class="line">`./locale/$&#123;language&#125;`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prefetch和preload应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>prefetch和preload区别</title>
      <link href="/2023/02/14/prefetch%E5%92%8Cpreload%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/14/prefetch%E5%92%8Cpreload%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="prefetch-与-preload-的区别是什么"><a href="#prefetch-与-preload-的区别是什么" class="headerlink" title="prefetch 与 preload 的区别是什么?"></a>prefetch 与 preload 的区别是什么?</h1><ul><li><p>先来看一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot; /&gt;</span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>preload 是⼀个声明式 fetch，可以强制浏览器在不阻塞 document 的 onload 事件的情况下请 </p><p>求资源。 preload 顾名思义就是⼀种预加载的⽅式，它通过声明向浏览器声明⼀个需要提前加载的资源，当资源真正被使⽤的时候⽴即执⾏，就⽆需等待⽹络的消耗 </p></li><li><p>prefetch 告诉浏览器这个资源将来可能需要，但是什么时间加载这个资源是由浏览器来决定的。 </p><p>若能预测到⽤户的⾏为，⽐如懒加载，点击到其它⻚⾯等则相当于提前预加载了需要的资源。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prefetch和preload区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/02/14/json%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/02/14/json%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="说说JSON的相关⽤法和应⽤场景？"><a href="#说说JSON的相关⽤法和应⽤场景？" class="headerlink" title="说说JSON的相关⽤法和应⽤场景？"></a>说说JSON的相关⽤法和应⽤场景？</h1><h3 id="三种⽤法"><a href="#三种⽤法" class="headerlink" title="三种⽤法"></a>三种⽤法</h3><p>简单值: 数字 字符串 布尔类型 </p><p>对象值 key value组成 必须添加双引号 value 可以是简单值 对象值 数组值 </p><p>数组值 内容可以是对象值 简单值 数组值</p><h3 id="应⽤场景"><a href="#应⽤场景" class="headerlink" title="应⽤场景"></a>应⽤场景</h3><p>⽹络传输的JSON数据 </p><p>项⽬的某些配置⽂件 </p><p>⾮关系型数据库将JSON作为存储⽂件</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> json应用场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>load和DOMcontentLoaded区别</title>
      <link href="/2023/02/14/load%E5%92%8CDOMcontentLoaded%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/02/14/load%E5%92%8CDOMcontentLoaded%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>load </p><ul><li>浏览器加载完所有的HTML 还加载完所有的外部资源 样式 图⽚等</li></ul><p>DOMContentLoaded </p><ul><li>HTML⽂档所有资源都加载完成 并构建了DOM树 但是⼀些外部资源还没有加载完成 如图⽚的src</li></ul><h3 id="事件委托的理解"><a href="#事件委托的理解" class="headerlink" title="事件委托的理解?"></a>事件委托的理解?</h3><p>利⽤事件的冒泡机制，以及事件对象中可以准确获知触发事件的元素机制(e.target)，将⼦元素事件委托 </p><p>给⽗元素处理的现象</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> load和DOMcontentLoaded区别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件委托</title>
      <link href="/2023/02/14/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2023/02/14/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<p>利⽤事件的冒泡机制，以及事件对象中可以准确获知触发事件的元素机制(e.target)，将⼦元素事件委托 </p><p>给⽗元素处理的现象。 </p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡事件</title>
      <link href="/2023/02/14/%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/02/14/%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡和事件捕获的理解"><a href="#冒泡和事件捕获的理解" class="headerlink" title="冒泡和事件捕获的理解"></a>冒泡和事件捕获的理解</h1><p>事件冒泡: </p><ul><li>从最内层的元素向外依次传递的顺序, 默认是事件冒泡</li></ul><p>事件捕获: </p><ul><li>从外层到内层依次传递的顺序 ,可以通过addEventListener(“click”,fn,true) 监听事件捕获</li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>attributy和Property</title>
      <link href="/2023/02/14/attributy%E5%92%8CProperty/"/>
      <url>/2023/02/14/attributy%E5%92%8CProperty/</url>
      
        <content type="html"><![CDATA[<h1 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h1><ul><li>浏览器解析HTML元素时 会将对应的属性(attribute)放在对应的元素对象上 </li><li>具体分为标准的属性和⾮标准的属性 <ul><li>标准属性: id class href type value等等 </li><li>⾮标准属性(⾃定义) :abc age height</li></ul></li></ul><h1 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h1><ul><li>对于标准的attribute 会在DOM对象上创建对应的property属性 </li><li>⼤多数情况下 他们是相互作⽤的 改变其中⼀个 另⼀个也会随之改变 </li><li>⼤多数情况 推荐获取attribute 使⽤property⽅式 因为它默认是有类型的</li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> attributy和Property </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑与&amp;&amp;和逻辑或||的本质和区别？</title>
      <link href="/2023/02/14/%E9%80%BB%E8%BE%91%E4%B8%8E&amp;&amp;%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2023/02/14/%E9%80%BB%E8%BE%91%E4%B8%8E&amp;&amp;%E5%92%8C%E9%80%BB%E8%BE%91%E6%88%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑与-也叫作短路与"><a href="#逻辑与-也叫作短路与" class="headerlink" title="逻辑与:也叫作短路与"></a>逻辑与:也叫作短路与</h1><ul><li>从左往右,依次计算 </li><li>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较 </li><li>true ,继续下⼀个⽐较 </li><li>false ,直接返回该运算元的初始值 </li><li>如果找到最后也没有找到,就返回最后⼀个运算元</li></ul><h1 id="逻辑或-也叫做短路或"><a href="#逻辑或-也叫做短路或" class="headerlink" title="逻辑或:也叫做短路或"></a>逻辑或:也叫做短路或</h1><p>从左往右,依次计算 </p><p>当计算第⼀个运算元,先隐式转换为Boolean值进⾏⽐较 </p><p>true ,直接返回该运算元的初始值 </p><p>false ,继续下⼀个⽐较 </p><p>如果找到最后也没有找到,就返回最后⼀个运算元</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==和===</title>
      <link href="/2023/02/14/==%E5%92%8C===/"/>
      <url>/2023/02/14/==%E5%92%8C===/</url>
      
        <content type="html"><![CDATA[<h1 id="x3D-x3D-普通相等"><a href="#x3D-x3D-普通相等" class="headerlink" title="&#x3D;&#x3D; (普通相等)"></a>&#x3D;&#x3D; (普通相等)</h1><p>在类型不相同的情况下, 会将运算元先转成Number的值, 再进⾏⽐较(隐式转换) </p><p>null⽐较特殊: null在进⾏⽐较的时候, 应该是会被当成⼀个对象和原⽣类型进⾏⽐较的 </p><h1 id="x3D-x3D-x3D-严格不等"><a href="#x3D-x3D-x3D-严格不等" class="headerlink" title="&#x3D;&#x3D;&#x3D; (严格不等)"></a>&#x3D;&#x3D;&#x3D; (严格不等)</h1><p>在类型不同的情况下,直接返回false</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型</title>
      <link href="/2023/02/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/02/14/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-中的常⻅数据类型"><a href="#JavaScript-中的常⻅数据类型" class="headerlink" title="JavaScript 中的常⻅数据类型"></a>JavaScript 中的常⻅数据类型</h1><h3 id="Number-gt-代表数据类型是数值"><a href="#Number-gt-代表数据类型是数值" class="headerlink" title="Number -&gt; 代表数据类型是数值"></a>Number -&gt; 代表数据类型是数值</h3><ul><li><p>整数 </p></li><li><p>浮点</p></li><li><p>数组</p></li></ul><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>String -&gt; 代表字符串类型 -&gt; 通常是⼀段⽂本</li></ul><h3 id="boolean-gt-布尔类型"><a href="#boolean-gt-布尔类型" class="headerlink" title="boolean -&gt; 布尔类型"></a>boolean -&gt; 布尔类型</h3><ul><li>true </li><li>false</li></ul><p>NULL -&gt; 空值 </p><p>undefifined -&gt; 变量未定义 </p><p>Object -&gt; 对象类型 </p><p>BigInt -&gt; ⼤整数类型 </p><p>Symbol -&gt; 符号类型</p>]]></content>
      
      
      <categories>
          
          <category> js数据类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常⻅的节点（Node）属性</title>
      <link href="/2023/02/14/%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/"/>
      <url>/2023/02/14/%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li><p>nodeType </p><ul><li><p>获取节点的类型 </p></li><li><p>⽐如 注释节点8 ⽂本节点3 元素节点1</p></li></ul></li><li><p>tagName </p><ul><li>获取元素的标签名词 仅适⽤于Element节点</li></ul></li><li><p>nodeName </p><ul><li>获取元素的标签名词 适⽤于任何Node节点</li></ul></li><li><p>innerHTML,textContent </p><ul><li>前者将元素中的HTML获取为字符串属性 后者仅仅获取⽂本内容</li></ul></li><li><p>outerHTML </p><ul><li>包含了完整的HTML </li><li>相当于innerHTML加上元素本身</li></ul></li><li><p>nodeValue&#x2F;data </p><ul><li>获取⾮元素节点的⽂本内容</li></ul></li><li><p>hidden </p><ul><li>⽤于设置元素隐藏(全局属性)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 节点（Node) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回调和匿名</title>
      <link href="/2023/02/14/%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8C%BF%E5%90%8D/"/>
      <url>/2023/02/14/%E5%9B%9E%E8%B0%83%E5%92%8C%E5%8C%BF%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h1><h4 id="⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数"><a href="#⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数" class="headerlink" title="⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数"></a>⼀个函数作为另外⼀个函数的参数，称之为回调函数，也称为⾼阶函数</h4><h1 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h1><h4 id="如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，"><a href="#如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，" class="headerlink" title="如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，"></a>如果在传⼊⼀个函数时，我们没有指定这个函数的名词或者通过函数表达式指定函数对应的变量，</h4><h4 id="那么这个函数称之为匿名函数"><a href="#那么这个函数称之为匿名函数" class="headerlink" title="那么这个函数称之为匿名函数"></a>那么这个函数称之为匿名函数</h4>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回调和匿名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM和document对象的理解</title>
      <link href="/2023/02/14/DOM%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2023/02/14/DOM%E5%92%8Cdocument%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对DOM和document对象的理解"><a href="#对DOM和document对象的理解" class="headerlink" title="对DOM和document对象的理解"></a>对DOM和document对象的理解</h1><h2 id="DOM-⽂档对象模型-Document-Object-Model-将⻚⾯所有的内容表示为可以修改的对象"><a href="#DOM-⽂档对象模型-Document-Object-Model-将⻚⾯所有的内容表示为可以修改的对象" class="headerlink" title="DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象"></a>DOM:⽂档对象模型(Document Object Model)将⻚⾯所有的内容表示为可以修改的对象</h2><ul><li><p>浏览器将我们编写在HTML中的每⼀个元素(Element)都抽象成了⼀个个对象 </p></li><li><p>所有这些对象都可以通过JavaScript来对其进⾏访问，那么我们就可以通过JavaScript来操作 </p></li><li><p>⻚⾯; </p></li><li><p>所以，我们将这个抽象过程称之为 ⽂档对象模型(Document Object Model)</p></li><li><p>Document节点表示的整个载⼊的⽹⻚，它的实例是全局的document对象:对DOM的所有操作都是从 document 对象开始的 </p></li><li><p>它是DOM的⼊⼝点，可以从document开始去访问任何节点元素;</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM和document对象的理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object_CSD</title>
      <link href="/2023/02/12/Object-CSD/"/>
      <url>/2023/02/12/Object-CSD/</url>
      
        <content type="html"><![CDATA[<h1 id="数据及结构与对象"><a href="#数据及结构与对象" class="headerlink" title="数据及结构与对象"></a>数据及结构与对象</h1><p>Math[PI] </p><p>此种语法，中括号里面是一个表达式 表达式计算结果应该是一个字符串 该字符串被当做要读取的属性的名 整个表达式返回该属性的属性值  </p><p>Math[“PI”]</p><p>Math[‘P’+’I’]</p><p>x&#x3D;”PI”</p><p>Math[x]</p><p>是可以的</p><p>&#x2F;&#x2F; 数组是值的“有序”集合</p><p> &#x2F;&#x2F; 对象是值的“具名”集合 </p><p>&#x2F;&#x2F; 在数组中，我们为值编号 </p><p>&#x2F;&#x2F; 在对象中，我们为值起名 </p><p>&#x2F;&#x2F; 有些语言里，对象又叫关联数组 </p><p>&#x2F;&#x2F;   把值与名字“关联”起来 </p><p>JS中一切皆对象（除空值以外）</p><p>因为一切都能读出属性</p><p>因为对于任何一个值来说，以下表达式都不报错</p><p>在其它很多语言里，能读出属性的只有对象</p><p>从能否可再拆分的角度讲，原始类型不算对象</p><p>但从能否读取属性的角度讲，原始类型也算对象，因为它们能读出属性</p><p>x &#x3D; 2</p><p>x.toFixed()</p><p>y &#x3D; ‘owiejfo’</p><p>y.length</p><p>y.toUpperCase()</p><p>z &#x3D; true</p><p>z.toString()</p><blockquote><p>c&#x3D;&#x3D; a&#x2F;&#x2F;相等运算判断对象时，返回的是两边是否是同一个对象<br>&#x2F;&#x2F;而判断原始类型时工返回的是两边的值是否相同</p></blockquote><p>为了找出对象具有的属性，可以使用 Object.keys 函数。 </p><p>你给它一个对象，它返回一个字符 </p><p>串数组 - 对象的属性名称</p><p>console.log(Object.keys({x: 0, y: 0, z: 2})); </p><p>&#x2F;&#x2F; → [“x”, “y”, “z”]</p><p><strong>Object.assign（）</strong> 方法将所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>（ 返回 true）和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">自有</a>（ 返回 true）属性从一个或多个源对象复制到目标对象，返回修改后的对象。 </p><p>实列一</p><p>let objectA &#x3D; {a: 1, b: 2}; </p><p>Object.assign(objectA, {b: 3, c: 4}); </p><p>console.log(objectA); </p><p>&#x2F;&#x2F; → {a: 1, b: 3, c: 4} </p><p>实列二</p><p>const target &#x3D; { a: 1, b: 2 };<br>const source &#x3D; { b: 4, c: 5 };</p><p>const returnedTarget &#x3D; Object.assign(target, source);</p><p>console.log(target);<br>&#x2F;&#x2F; expected output: Object { a: 1, b: 4, c: 5 }</p><p>console.log(returnedTarget);<br>&#x2F;&#x2F; expected output: Object { a: 1, b: 4, c: 5 }</p><p>copyWithin（0，3，6）将3-6复制到前面</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Array</title>
      <link href="/2023/02/12/Array/"/>
      <url>/2023/02/12/Array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h1><p>数组是值的有序集合</p><p>元素在数组中从0开始编号</p><p>创建数组 var a &#x3D; [1,2,3]</p><p>创建数组 var a &#x3D; Array(6) 创建长度为6的数组</p><p>创建数组 var a &#x3D; Array(6).fill(0) 创建长度为6的数组</p><p>创建数组 var a &#x3D; Array(6,5,4,3) 创建由6，5，4，3组成的数组</p><p>获取数组的长度 a.length</p><p>获取数组中的元素 a[i] ，i是元素在数组中的编号&#x2F;索引&#x2F;下标，下标只有整数</p><p>a[表达式]，，表达式计算出一个整数，</p><p>这个整体也是一个表达式，求值结果为数组中的某一项</p><p>a[i] &#x3D; 8 向数组的第i项赋值，之前的值就被扔了</p><p>任意值都可以放入数组中，如null，undefined，2，3，5，”owiefj”, true，函数，数组（因为数组本身也是值）</p><p>向数组末尾添加一个元素： a.push(1) 返回数组新的长度</p><p>向数组末尾添加多个元素： a.push(1,2,3,4) 返回数组新的长度</p><p>从数组的末尾删除并返回元素 var result &#x3D; a.pop()</p><p>向数组的开头添加一个元素 a.unshift(1) 返回数组新的长度</p><p>向数组的开头添加多个元素 a.unshift(1,2,3,4) 返回数组新的长度</p><p>从数组的开头删除并返回元素 var result &#x3D; a.shift()</p><p>将数组的内容填充为某个值 a.fill(5) 将数组所有的值都填成5</p><p>读取数组不存在的下标会得到undefined</p>]]></content>
      
      
      <categories>
          
          <category> js基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2023/02/12/Map/"/>
      <url>/2023/02/12/Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Map的封装"><a href="#Map的封装" class="headerlink" title="Map的封装"></a>Map的封装</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">class Map2 &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">    this._keys = [] // 用来存储每组映射的key</span><br><span class="line"></span><br><span class="line">    this._vals = [] // 用来存储每组映射的val</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return this._vals[keyIdx]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123; // 判断映射中是否存在某个key的映射</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123; // 设置key的映射目标为val</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this._vals[keyIdx] = val</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      this._keys.push(key)</span><br><span class="line"></span><br><span class="line">      this._vals.push(val)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete(key) &#123; // 删除key的映射对</span><br><span class="line"></span><br><span class="line">    var keyIdx = this._keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this._keys.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      this._vals.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123; // 清空所有的映射</span><br><span class="line"></span><br><span class="line">    this._keys = []</span><br><span class="line"></span><br><span class="line">    this._vals = []</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // size() &#123; // 返回当前Map中映射对的数量</span><br><span class="line"></span><br><span class="line">  //   return this._keys.length</span><br><span class="line"></span><br><span class="line">  // &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Map3 &#123;</span><br><span class="line"></span><br><span class="line">  #keys = [] // private class field</span><br><span class="line"></span><br><span class="line">  #vals = [] // private class field</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(key) &#123;</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return this.#vals[keyIdx]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has(key) &#123; // 判断映射中是否存在某个key的映射</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(key, val) &#123; // 设置key的映射目标为val</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this.#vals[keyIdx] = val</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      this.#keys.push(key)</span><br><span class="line"></span><br><span class="line">      this.#vals.push(val)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delete(key) &#123; // 删除key的映射对</span><br><span class="line"></span><br><span class="line">    var keyIdx = this.#keys.indexOf(key)</span><br><span class="line"></span><br><span class="line">    if (keyIdx &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">      this.#keys.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      this.#vals.splice(keyIdx, 1)</span><br><span class="line"></span><br><span class="line">      return true</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123; // 清空所有的映射</span><br><span class="line"></span><br><span class="line">    this.#keys = []</span><br><span class="line"></span><br><span class="line">    this.#vals = []</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size() &#123; // 返回当前Map中映射对的数量</span><br><span class="line"></span><br><span class="line">    return this.#keys.length</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">class Stack &#123;</span><br><span class="line"></span><br><span class="line">  #size = 0</span><br><span class="line"></span><br><span class="line">  #top = null // 用于存储栈内元素的链表的头结点，由于头结点是栈顶，所以起名top</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 将元素val放入栈顶</span><br><span class="line">push(val) &#123;</span><br><span class="line">  var node = &#123;</span><br><span class="line">    val: val,</span><br><span class="line">    next: this.#top,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.#top = node</span><br><span class="line">  this.#size++</span><br><span class="line"></span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 返回栈顶元素并将其出栈</span><br><span class="line">pop() &#123;</span><br><span class="line">  if (this.#top) &#123;</span><br><span class="line">    var result = this.#top.val</span><br><span class="line">    this.#top = this.#top.next</span><br><span class="line">    this.#size--</span><br><span class="line">    return result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查看栈顶元素的值，但不让它出栈</span><br><span class="line">peek() &#123;</span><br><span class="line">  if (this.#top) &#123;</span><br><span class="line">    return this.#top.val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line">  return this.#size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 使用链表实现队列的抽象数据结构<br>  class Queue {<br>    constructor() {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进队</span><br><span class="line">enqueue(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 出队，将队头元素返回并从队列里删除</span><br><span class="line">dequeue() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 查看队头元素的值</span><br><span class="line">peek() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 表示一个集合：不重复的无序元素组成东西。<br>  class Group {<br>    constructor() {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">// 为集合中添加一个元素</span><br><span class="line">add(val) &#123;</span><br><span class="line"></span><br><span class="line">  return this</span><br><span class="line">&#125;</span><br><span class="line">// 返回集合中是否有val这个元素</span><br><span class="line">has(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 从集合中删除val元素，返回是否删除成功</span><br><span class="line">delete(val) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">size() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 二维向量<br>  class Vector {<br>    constructor(x, y) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">// 用当前向量加上一个向量v，返回新的结果向量</span><br><span class="line">plus(v) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 用当前向量减去一个向量v，返回新的结果向量</span><br><span class="line">minus(v) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">length() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  &#x2F;&#x2F; 实现复数及其四则运算<br>  class Complex {<br>    constructor(real, imag) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">plus(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">minus(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mul(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">divide(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以 (3+2j) 的形式返回复数的字符串形式</span><br><span class="line">toString() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>  var c1 &#x3D; new Complex(2, 3)<br>  var c2 &#x3D; new Complex(5, -1)<br>  var c3 &#x3D; c1.mul(c2)</p><p></script></p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdom</title>
      <link href="/2023/02/12/JSDom/"/>
      <url>/2023/02/12/JSDom/</url>
      
        <content type="html"><![CDATA[<p>元素的查找：<br>  getElements?.*()</p><p>元素的周围指针：<br>  el.firstChild&#x2F;lastChild&#x2F;nextSibiling&#x2F;previousSibiling<br>  el.parentNode&#x2F;parentElement<br>  el.firstElementChild&#x2F;lastElementChild<br>  el.nextElementSibiling&#x2F;previousElementSibiling<br>  el.childNodes&#x2F;children</p><p>元素的常用方法：<br>  对结点进行增删改<br>  el.appendChild(node)<br>  el.removeChild(node)<br>    node.remove()<br>  el.replaceChild(node, baseNode)<br>    baseNode.replaceWith(node)<br>  el.insertBefore(node, baseNode)</p><p>attr&amp;prop：<br>  node.xxxxx   dom property<br>  标准属性大都可以使用node.prop的形式访问,如<br>    id,title,alt,src,href,type,name,value<br>    class要用className,label的for属性要用htmlFor<br>  node.get&#x2F;set&#x2F;remove&#x2F;hasAttribute()   html attribute</p><p>新浏览器的一些方便的dom功能:<br>  el.classList.add&#x2F;remove&#x2F;replace&#x2F;toggle&#x2F;contains 访问及操作元素的class<br>  el.dataset.xxxYyyy 访问data-属性<br>  el.remove() 删除元素自身<br>    el.parentElement.removeChild(el)<br>  el.replaceWith(targetNode) 用targetNode替换el<br>  el.append(string, node, node, string, …)<br>  el.prepend(string, node, node, string, …)</p><p>  el.innerHTML 元素内部的结点的html表示,也可以赋值<br>  el.innerText 元素内部的文本内容,会受css影响<br>  el.textContent 元素内部的文本结点的值按顺序拼接得到的内容<br>  el.outerHTML 包含元素自身及内部的结点的html表示,也可以赋值,赋值会替换掉这个元素<br>    相当于在innerHTML的结果前后加上元素自身的开始和结束标签<br>  el.outerText 读取时等价于innerText,赋值时相当于用字符串替换该结点</p><p>function getInnerHTML(node) {</p><p>  var result &#x3D; ‘’<br>  for (var child of node.childNodes) {<br>      result +&#x3D; getOuterHTML(child)<br>  }<br>  return result</p><p>}</p><p>function getInnerHTML(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var result &#x3D; ‘’<br>    for (var child of node.childNodes) {<br>      if (child.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>        result +&#x3D; getInnerHTML(child)<br>      } else<br>        result +&#x3D; <code>&lt;$&#123;child.tagName&#125;&gt;</code> + getInnerHTML(child) + <code>&lt;/$&#123;child.tagName&#125;&gt;</code><br>    }<br>    return result<br>  }<br>}</p><p>function getTextContent(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var start &#x3D; &#96;&#96;<br>    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) {<br>      start +&#x3D; getTextContent(node.childNodes[i])<br>    }<br>    return start<br>  }<br>}</p><p>function getOuterHTML(node) {<br>  if (node.nodeType &#x3D;&#x3D; document.TEXT_NODE) {<br>    return node.nodeValue<br>  } else {<br>    var tagName &#x3D; node.tagName.toLowerCase()<br>    var start &#x3D; <code>&lt;$&#123;tagName&#125;&gt;</code><br>    for (var i &#x3D; 0; i &lt; node.childNodes.length; i++) {<br>      start +&#x3D; getOuterHTML(node.childNodes[i])<br>    }<br>    return start + <code>&lt;/$&#123;tagName&#125;&gt;</code><br>  }<br>}</p><p>&#x2F;&#x2F; node.getElementsByTagName(tagName)<br>&#x2F;&#x2F; getElementsByTagName(node, tagName)</p><p>function getElementsByTagName(node, tagName) {<br>  var result &#x3D; []<br>  for (var child of node.children) {<br>    if (child.tagName &#x3D;&#x3D; tagName) {<br>      result.push(child)<br>    }<br>    result.push(…getElementsByTagName(child, tagName))<br>  }<br>  return result<br>}</p><p>function getElementsByTagName(node, tagName) {<br>  var result &#x3D; []<br>  &#x2F;&#x2F; 先序遍历node为根结点的dom树<br>  traverseDOM(node, it &#x3D;&gt; {<br>    &#x2F;&#x2F; 遇到的每个结点,如果是要找的标签名,则push到结果里<br>    if (it.tagName &#x3D;&#x3D; tagName) {<br>      result.push(it)<br>    }<br>  })<br>  &#x2F;&#x2F; 结果是一定不能包含根结点的<br>  &#x2F;&#x2F; 如果根结点在结果里,那么一定在第0项<br>  if (result[0] &#x3D;&#x3D; node) {<br>    result.shift()<br>  }<br>  return result<br>}</p><p>function traverseDOM(node, action &#x3D; console.log) {<br>  if (node.nodeType &#x3D;&#x3D; document.ELEMENT_NODE) {<br>    action(node)<br>    for (var child of node.children) {<br>      traverseDOM(child, action)<br>    }<br>  }<br>}</p><p>&#x2F;&#x2F; 带提前结束功能的遍历函数,让action返回false以提前结束<br>function traverseDOM(node, action &#x3D; console.log) {<br>  if (node.nodeType &#x3D;&#x3D; document.ELEMENT_NODE) {<br>    if (action(node) &#x3D;&#x3D;&#x3D; false) {<br>      return false<br>    }<br>    for (var child of node.children) {<br>      if (traverseDOM(child, action) &#x3D;&#x3D;&#x3D; false) {<br>        return false<br>      }<br>    }<br>  }<br>}</p><p>function getElementById(id, node &#x3D; document.documentElement) {<br>  if (node.id &#x3D;&#x3D;&#x3D; id) {<br>    return node<br>  } else {<br>    for (var child of node.children) {<br>      var result &#x3D; getElementById(id, child)<br>      if (result) {<br>        return result<br>      }<br>    }<br>    return null<br>  }<br>}</p><p>function getElementById(id) {<br>  var result &#x3D; null<br>  try {<br>    traverseDOM(document.documentElement, it &#x3D;&gt; {<br>      if (it.id &#x3D;&#x3D;&#x3D; id) {<br>        result &#x3D; it<br>        throw 2<br>      }<br>    })<br>  } catch (e) {<br>    if (e &#x3D;&#x3D;&#x3D; 2) {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; else &#123;</span><br><span class="line">  throw e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }<br>  return result<br>}<br>function getElementById(id) {<br>  var result &#x3D; null<br>  traverseDOM(document.documentElement, it &#x3D;&gt; {<br>    if (it.id &#x3D;&#x3D;&#x3D; id) {<br>      result &#x3D; it<br>      return false<br>    }<br>  })<br>  return result<br>}</p>]]></content>
      
      
      <categories>
          
          <category> js高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2023/02/11/flex%E5%B8%83%E5%B1%80/"/>
      <url>/2023/02/11/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="flex"><a href="#flex" class="headerlink" title="flex:"></a>flex:</h1><p>大号的行内布局</p><h3 id="外层元素-flex-container-flex-容器"><a href="#外层元素-flex-container-flex-容器" class="headerlink" title="外层元素: flex container flex 容器"></a>外层元素: flex container flex 容器</h3><p>flex 窗口的子元素: flex item flex 元素</p><ul><li><p>flex-wrap:wrap 折行</p></li><li><p>flex-grow:0; &#x2F;_ 扩张权重_&#x2F;宽度的权重 默认为 0</p></li><li><p>flex-grow:0.x; &#x2F;<em>按照百分比获取剩余空间</em>&#x2F; 所有求和不超过 100%也就是 1 生效</p></li><li><p>flex-shrink:; &#x2F;<em>收缩系数</em>&#x2F; 默认 1</p></li><li><ul><li><p>不是 flex item 的 flex 父元素从外面看就像块元素一样<br>如宽度会打满包含块<br>但是子元素的 margin 不会超出去<br>但是相邻的元素垂直方向的 margin 还是会合并的</p></li><li><p>收缩或者扩张都不会让元素超出自己 min-w&#x2F;h 以及 max-w&#x2F;h 设定 的尺寸<br>收缩不能收到比自己的 min-width 还小<br>扩张不能扩张到比自己的 max-width 还大<br>收缩只发生在不折行的时候<br>因为如果折行就不可能存在空间不够的情况<br>flex 父元素”垂直”方向上的额外空间,只会均等的分配给每一行<br>当高度固定了如果还有额外空间用 height:auto;会自动分配填满</p></li></ul><h3 id="flex-父元素用来调用子元素摆放属性-justify-content"><a href="#flex-父元素用来调用子元素摆放属性-justify-content" class="headerlink" title="flex 父元素用来调用子元素摆放属性 justify-content"></a>flex 父元素用来调用子元素摆放属性 justify-content</h3><pre><code>* justify-content  设定一&quot;行&quot;的元素在行中的&quot;水平&quot;分布 start 项目与容器的左侧对齐。 end 项目与容器的右侧对齐 center 项目在容器的中心对齐 space-between 项目以相等的间距显示。 space-around 项目以等间距显示 space-evenly 平均分配物品</code></pre><p>项目在它们周围有相等的空间</p></li></ul><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p>设定一”行”的元素在行中的”垂直”分布<br>start 项目与容器顶部对齐</p><p>end 项目与容器底部对齐</p><p>center 项目在容器的垂直中心对</p><p>baseline 项目显示在容器的基线处</p><p>stretch 物品被拉伸以适合容器</p><ul><li><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>​ 设定所有行(“行们”)在父元素垂直方向的分布<br>(设置父元素垂直方向上额外空间的分配)</p><pre><code> start flex-start: 线装在容器的顶部 end flex-end: 线装在容器的底部 center center: 线在容器的垂直中心包装 space-between：行以相等的间距显示 两边对齐   space-around  行以相等的间距显示在它们周围 space-evenly平均分配物品   项目在它们周围有相等的空间   stretch(额外空间均分给每一行)：线条被拉伸以适合容器   flex父元素&quot;垂直&quot;方向上的额外空间,只会均等的分配给每一行 * 不是flex item的flex父元素从外面看就像块元素一样如宽度会打满包含块   但是子元素的margin不会超出去   但是相邻的元素垂直方向的margin还是合并的</code></pre></li></ul><h3 id="flex-子元素用来调整自身摆放属性"><a href="#flex-子元素用来调整自身摆放属性" class="headerlink" title="flex 子元素用来调整自身摆放属性"></a>flex 子元素用来调整自身摆放属性</h3><pre><code>   align-self 类似align-items,但是只调整自己   order 调整自己的显示顺序(不是层叠顺序)   flex子元素不用定位就可以使用z-index属性  flex: 在一个属性上直接设置flex子元素的flex-grow flex-shrink flex-basis</code></pre><ul><li><p>flex: auto;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: auto;</code></pre></li><li><p>flex: 1;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: 0%;</code></pre></li><li><p>flex: 0;</p><pre><code>flex-grow: 0;flex-shrink: 1;flex-basis: 0%;</code></pre></li><li><p>flex: 100px;</p><pre><code>flex-grow: 1;flex-shrink: 1;flex-basis: 100px;</code></pre></li><li><ul><li><p>flex-basis: 设定元素在主轴方向上的初始尺寸<br>当主轴水平时，它相当于 width</p><p>当主轴垂直时，它相当于 height</p><p>当它与 width&#x2F;height 一起用的时候，如果 flex-basis 的<br>值不为 auto，则它更优先</p></li></ul></li></ul><h3 id="flex-父元素的轴向-flex-direction"><a href="#flex-父元素的轴向-flex-direction" class="headerlink" title="flex 父元素的轴向:flex-direction"></a>flex 父元素的轴向:flex-direction</h3><pre><code>flex-direction: 设定主轴方向row 向右 项目的放置与文本方向相同row-reverse 向左 项目放置在与文本方向相反的位置column 向下 项目从上到下放置column-reverse 向上  项目从下到上放置</code></pre><h3 id="flex-wrap-设定交叉轴方向-交叉轴肯定跟主轴是垂直的"><a href="#flex-wrap-设定交叉轴方向-交叉轴肯定跟主轴是垂直的" class="headerlink" title="flex-wrap 设定交叉轴方向,交叉轴肯定跟主轴是垂直的"></a>flex-wrap 设定交叉轴方向,交叉轴肯定跟主轴是垂直的</h3><p>wrap 垂直与主轴,向右或向下</p><ul><li><p>项目环绕到其他行 ，类似于折行</p></li><li></li><li><p>wrap-reverse 垂直与主轴,向左或向上</p></li><li><p>项目反向环绕到附加行。</p></li><li><p>nowrap 每个项目都适合一行</p></li><li><p>不设定交叉轴方向,即不折行,所有元素在同一行或同一列</p></li><li></li><li><p>flex-flow 在一个属性上直接设置 flex-direction 和<br>flex-wrap 换行</p><p>flex-flow: wrap column; 换行 向下 项目从上到下放置</p><p>flex-grow 设定主轴方向上额外空间的分配<br>flex-shrink 设定主轴方向上空间收缩的系数</p><h2 id="flex-flow-弹性容器"><a href="#flex-flow-弹性容器" class="headerlink" title="flex-flow 弹性容器"></a>flex-flow 弹性容器</h2><p>*_ &#x2F;_ flex-flow: &lt;’flex-direction’&gt; *&#x2F;</p><p>flex-flow: row; 向右 项目的放置与文本方向相同</p><p>flex-flow: row-reverse; 向左 项目放置在与文本方向相反的位置</p><p>flex-flow: column; 向下 项目从上到下放置</p><p>flex-flow: column-reverse; 设置反转</p><p>&#x2F;_ flex-flow: &lt;’flex-wrap’&gt; _&#x2F;</p><p>flex-flow: nowrap;</p><p>flex-flow: wrap; 换行</p><p>flex-flow: wrap-reverse;</p><p>&#x2F;_ flex-flow: &lt;’flex-direction’&gt; and &lt;’flex-wrap’&gt; _&#x2F;</p><p>flex-flow: row nowrap;</p><p>flex-flow: column wrap;</p><p>flex-flow: column-reverse wrap-reverse;</p><p>&#x2F;_ Global values _&#x2F;</p><p>flex-flow: inherit;</p><p>flex-flow: initial;</p><p>flex-flow: revert;</p><p>flex-flow: revert-layer;</p><p>flex-flow: unset;</p><p>​</p></li></ul><h4 id="flex-父元素中的匿名文本"><a href="#flex-父元素中的匿名文本" class="headerlink" title="flex 父元素中的匿名文本"></a>flex 父元素中的匿名文本</h4><pre><code>flex父元素中的匿名文本相当于将该文本包进一个标签但不给该标签设置任何属性但它会受到flex父元素 justify-content, align-items, align-content属性的影响flex子元素的的margin：auto会均等的分配额外的空间，但晚于flex-grow对空间的占用</code></pre><h2 id="gap"><a href="#gap" class="headerlink" title="gap"></a>gap</h2><pre><code>设置在flex父元素用于指定子元素之间的间隙gap: &lt;row-gap&gt; &lt;column-gap&gt;;row-gap:column-gap: 行内flex元素,外面看是行内,里面看是flexdisplay: inline-flex 定位flex元素,外面看是定位,里面看是flexdisplay: flex;position: absolute;浮动flex元素,外面看是浮动,里面看是flexdisplay: flex;float: left;</code></pre><p><img src="D:\Blog\source_posts\flex.jpg" alt="flex"></p>]]></content>
      
      
      <categories>
          
          <category> flex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
